{"version":3,"file":"makeup-keyboard-trap/index.min.js","mappings":";;;;;;;AAAa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,eAAe;AACf,YAAY;AACZ,cAAc;AACd,+CAA+C,mBAAO,CAAC,GAAmB;AAC1E,qCAAqC,iCAAiC;AACtE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;ACrHa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,kBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;UCnCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;ACtBa;;AAEb,2CAA2C,mBAAO,CAAC,GAAsB;AACzE,yCAAyC,4EAA4E,oDAAoD,uCAAuC,gBAAgB,+BAA+B,4EAA4E,qBAAqB,+BAA+B,eAAe,wCAAwC,2JAA2J,WAAW;AAC5lB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC,E","sources":["webpack://root/./packages/core/makeup-keyboard-trap/dist/cjs/index.js","webpack://root/./packages/core/makeup-keyboard-trap/node_modules/makeup-focusables/dist/cjs/index.js","webpack://root/webpack/bootstrap","webpack://root/./docs/core/makeup-keyboard-trap/index.compiled.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.refresh = refresh;\nexports.trap = trap;\nexports.untrap = untrap;\nvar _makeupFocusables = _interopRequireDefault(require(\"makeup-focusables\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nconst _observer = typeof window !== \"undefined\" ? new MutationObserver(refresh) : null;\n\n// for the element that will be trapped\nlet trappedEl;\n\n// for the trap boundary/bumper elements\nlet topTrap;\nlet outerTrapBefore;\nlet innerTrapBefore;\nlet innerTrapAfter;\nlet outerTrapAfter;\nlet botTrap;\n\n// for the first and last focusable element inside the trap\nlet firstFocusableElement;\nlet lastFocusableElement;\nfunction createTrapBoundary() {\n  const trapBoundary = document.createElement(\"div\");\n  trapBoundary.setAttribute(\"aria-hidden\", \"true\");\n  trapBoundary.setAttribute(\"tabindex\", \"0\");\n  trapBoundary.className = \"keyboard-trap-boundary\";\n  return trapBoundary;\n}\nfunction setFocusToFirstFocusableElement() {\n  firstFocusableElement.focus();\n}\nfunction setFocusToLastFocusableElement() {\n  lastFocusableElement.focus();\n}\nfunction createTraps() {\n  topTrap = createTrapBoundary();\n  outerTrapBefore = topTrap.cloneNode();\n  innerTrapBefore = topTrap.cloneNode();\n  innerTrapAfter = topTrap.cloneNode();\n  outerTrapAfter = topTrap.cloneNode();\n  botTrap = topTrap.cloneNode();\n  topTrap.addEventListener(\"focus\", setFocusToFirstFocusableElement);\n  outerTrapBefore.addEventListener(\"focus\", setFocusToFirstFocusableElement);\n  innerTrapBefore.addEventListener(\"focus\", setFocusToLastFocusableElement);\n  innerTrapAfter.addEventListener(\"focus\", setFocusToFirstFocusableElement);\n  outerTrapAfter.addEventListener(\"focus\", setFocusToLastFocusableElement);\n  botTrap.addEventListener(\"focus\", setFocusToLastFocusableElement);\n}\nfunction untrap() {\n  if (trappedEl) {\n    topTrap = safeDetach(topTrap);\n    outerTrapBefore = safeDetach(outerTrapBefore);\n    innerTrapBefore = safeDetach(innerTrapBefore);\n    innerTrapAfter = safeDetach(innerTrapAfter);\n    outerTrapAfter = safeDetach(outerTrapAfter);\n    botTrap = safeDetach(botTrap);\n    trappedEl.classList.remove(\"keyboard-trap--active\");\n\n    // let observers know the keyboard is no longer trapped\n    trappedEl.dispatchEvent(new CustomEvent(\"keyboardUntrap\", {\n      bubbles: true\n    }));\n    trappedEl = null;\n    _observer?.disconnect();\n  }\n  return trappedEl;\n}\nfunction safeDetach(el) {\n  const parent = el.parentNode;\n  return parent ? parent.removeChild(el) : el;\n}\nfunction trap(el) {\n  if (!topTrap) {\n    createTraps();\n  } else {\n    untrap();\n  }\n  trappedEl = el;\n\n  // when bundled up with isomorphic components on the server, this code is run,\n  // so we must check if 'document' is defined.\n  const body = typeof document === \"undefined\" ? null : document.body;\n  const focusableElements = (0, _makeupFocusables.default)(trappedEl, true);\n  firstFocusableElement = focusableElements[0];\n  lastFocusableElement = focusableElements[focusableElements.length - 1];\n  body.insertBefore(topTrap, body.childNodes[0]);\n  trappedEl.parentNode.insertBefore(outerTrapBefore, trappedEl);\n  trappedEl.insertBefore(innerTrapBefore, trappedEl.childNodes[0]);\n  trappedEl.appendChild(innerTrapAfter);\n  trappedEl.parentNode.insertBefore(outerTrapAfter, trappedEl.nextElementSibling);\n  body.appendChild(botTrap);\n\n  // let observers know the keyboard is now trapped\n  trappedEl.dispatchEvent(new CustomEvent(\"keyboardTrap\", {\n    bubbles: true\n  }));\n  trappedEl.classList.add(\"keyboard-trap--active\");\n  _observer?.observe(el, {\n    childList: true,\n    subtree: true\n  });\n  return trappedEl;\n}\nfunction refresh() {\n  if (topTrap && trappedEl) {\n    let focusableElements = (0, _makeupFocusables.default)(trappedEl, true);\n    focusableElements = focusableElements.filter(function (el) {\n      return !el.classList.contains(\"keyboard-trap-boundary\");\n    });\n    firstFocusableElement = focusableElements[0];\n    lastFocusableElement = focusableElements[focusableElements.length - 1];\n  }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nconst focusableElList = [\"a[href]\", \"area[href]\", \"button:not([disabled])\", \"embed\", \"iframe\", \"input:not([disabled])\", \"object\", \"select:not([disabled])\", \"textarea:not([disabled])\", \"*[tabindex]\", \"*[contenteditable]\"];\nconst focusableElSelector = focusableElList.join();\nfunction _default(el) {\n  let keyboardOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let callback = arguments.length > 2 ? arguments[2] : undefined;\n  if (callback) {\n    const request = requestAnimationFrame(() => {\n      callback(getFocusables(el, keyboardOnly));\n    });\n    return () => {\n      cancelAnimationFrame(request);\n    };\n  }\n  return getFocusables(el, keyboardOnly);\n}\nfunction getFocusables(el) {\n  let keyboardOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let focusableEls = Array.prototype.slice.call(el.querySelectorAll(focusableElSelector));\n\n  // filter out elements with display: none or nested in a display: none parent\n  focusableEls = focusableEls.filter(function (focusableEl) {\n    return !!(focusableEl.offsetWidth || focusableEl.offsetHeight || focusableEl.getClientRects().length);\n  });\n  if (keyboardOnly === true) {\n    focusableEls = focusableEls.filter(function (focusableEl) {\n      return focusableEl.getAttribute(\"tabindex\") !== \"-1\";\n    });\n  }\n  return focusableEls;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\n\nvar keyboardTrap = _interopRequireWildcard(require(\"makeup-keyboard-trap\"));\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }\n// REQUIRE\n// const keyboardTrap = require('makeup-keyboard-trap');\n\n// IMPORT\n\nconst trap = document.getElementById(\"trap\");\nconst btn = document.querySelector(\"button\");\nbtn.addEventListener(\"click\", function () {\n  if (this.getAttribute(\"aria-pressed\") === \"true\") {\n    keyboardTrap.untrap();\n  } else {\n    keyboardTrap.trap(this.parentNode);\n  }\n});\ndocument.addEventListener(\"keyboardTrap\", function (e) {\n  console.log(this, e);\n});\ndocument.addEventListener(\"keyboardUntrap\", function (e) {\n  console.log(this, e);\n});\ntrap.addEventListener(\"keyboardUntrap\", function (e) {\n  console.log(this, e);\n  btn.innerText = \"Trap\";\n  btn.setAttribute(\"aria-pressed\", \"false\");\n});\ntrap.addEventListener(\"keyboardTrap\", function (e) {\n  console.log(this, e);\n  btn.innerText = \"Untrap\";\n  btn.setAttribute(\"aria-pressed\", \"true\");\n});"],"names":[],"sourceRoot":""}