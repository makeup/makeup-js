{"version":3,"file":"makeup-screenreader-trap/index.min.js","mappings":";;;;;;;AAAa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,YAAY;AACZ,cAAc;AACd,mCAAmC,mBAAO,CAAC,GAAW;AACtD,uCAAuC,+CAA+C,0CAA0C,kDAAkD,mBAAmB;AACrM,yCAAyC,uCAAuC,2EAA2E,cAAc,qCAAqC,oCAAoC,UAAU,iBAAiB,gEAAgE,0CAA0C,8BAA8B,0DAA0D,wEAAwE;AACvhB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;AC7Ha;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,oBAAoB;AACpB,mBAAmB;AACnB,8BAA8B;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;UChEA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;ACtBa;;AAEb,+CAA+C,mBAAO,CAAC,GAA0B;AACjF,uCAAuC,+CAA+C,0CAA0C,kDAAkD,mBAAmB;AACrM,yCAAyC,uCAAuC,2EAA2E,cAAc,qCAAqC,oCAAoC,UAAU,iBAAiB,gEAAgE,0CAA0C,8BAA8B,0DAA0D,wEAAwE;AACvhB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC,E","sources":["webpack://root/./packages/core/makeup-screenreader-trap/dist/cjs/index.js","webpack://root/./packages/core/makeup-screenreader-trap/dist/cjs/util.js","webpack://root/webpack/bootstrap","webpack://root/./docs/core/makeup-screenreader-trap/index.compiled.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.trap = trap;\nexports.untrap = untrap;\nvar util = _interopRequireWildcard(require(\"./util.js\"));\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\n// the main landmark\nlet mainEl;\n\n// the element that will be trapped\nlet trappedEl;\n\n// collection of elements that get 'dirtied' with aria-hidden attr or hidden prop\nlet dirtyObjects;\n\n// filter function for svg elements\nconst filterSvg = item => item.tagName.toLowerCase() !== \"svg\";\nfunction showElementPrep(el, useHiddenProperty) {\n  let preparedElement;\n  if (useHiddenProperty === false) {\n    preparedElement = prepareElement(el, \"aria-hidden\", \"false\");\n  } else {\n    preparedElement = prepareElement(el, \"hidden\", false);\n  }\n  return preparedElement;\n}\nfunction hideElementPrep(el, useHiddenProperty) {\n  let preparedElement;\n  if (useHiddenProperty === false) {\n    preparedElement = prepareElement(el, \"aria-hidden\", \"true\");\n  } else {\n    preparedElement = prepareElement(el, \"hidden\", true);\n  }\n  return preparedElement;\n}\nfunction prepareElement(el, attributeName, dirtyValue) {\n  const isProperty = typeof dirtyValue === \"boolean\";\n  return {\n    el,\n    attributeName,\n    cleanValue: isProperty ? el[attributeName] : el.getAttribute(attributeName),\n    dirtyValue,\n    isProperty\n  };\n}\nfunction dirtyElement(preparedObj) {\n  if (preparedObj.isProperty === true) {\n    preparedObj.el[preparedObj.attributeName] = preparedObj.dirtyValue;\n  } else {\n    preparedObj.el.setAttribute(preparedObj.attributeName, preparedObj.dirtyValue);\n  }\n}\nfunction cleanElement(preparedObj) {\n  if (preparedObj.cleanValue) {\n    if (preparedObj.isProperty === true) {\n      preparedObj.el[preparedObj.attributeName] = preparedObj.cleanValue;\n    } else {\n      preparedObj.el.setAttribute(preparedObj.attributeName, preparedObj.cleanValue);\n    }\n  } else {\n    preparedObj.el.removeAttribute(preparedObj.attributeName);\n  }\n}\nfunction untrap() {\n  if (trappedEl) {\n    // restore 'dirtied' elements to their original state\n    dirtyObjects.forEach(item => cleanElement(item));\n    dirtyObjects = [];\n\n    // 're-enable' the main landmark\n    if (mainEl) {\n      mainEl.setAttribute(\"role\", \"main\");\n    }\n\n    // let observers know the screenreader is now untrapped\n    trappedEl.dispatchEvent(new CustomEvent(\"screenreaderUntrap\", {\n      bubbles: true\n    }));\n    trappedEl = null;\n  }\n}\nconst defaultOptions = {\n  useHiddenProperty: false\n};\nfunction trap(el, selectedOptions) {\n  // ensure current trap is deactivated\n  untrap();\n  const options = Object.assign({}, defaultOptions, selectedOptions);\n\n  // update the trapped el reference\n  trappedEl = el;\n\n  // update the main landmark reference\n  mainEl = document.querySelector('main, [role=\"main\"]');\n\n  // we must remove the main landmark to avoid issues on voiceover iOS\n  if (mainEl) {\n    mainEl.setAttribute(\"role\", \"presentation\");\n  }\n\n  // cache all ancestors, siblings & siblings of ancestors for trappedEl\n  const ancestors = util.getAncestors(trappedEl);\n  let siblings = util.getSiblings(trappedEl);\n  let siblingsOfAncestors = util.getSiblingsOfAncestors(trappedEl);\n\n  // if using hidden property, filter out SVG elements as they do not support this property\n  if (options.useHiddenProperty === true) {\n    siblings = siblings.filter(filterSvg);\n    siblingsOfAncestors = siblingsOfAncestors.filter(filterSvg);\n  }\n\n  // prepare elements\n  dirtyObjects = [showElementPrep(trappedEl, options.useHiddenProperty)].concat(ancestors.map(item => showElementPrep(item, options.useHiddenProperty))).concat(siblings.map(item => hideElementPrep(item, options.useHiddenProperty))).concat(siblingsOfAncestors.map(item => hideElementPrep(item, options.useHiddenProperty)));\n\n  // update DOM\n  dirtyObjects.forEach(item => dirtyElement(item));\n\n  // let observers know the screenreader is now trapped\n  trappedEl.dispatchEvent(new CustomEvent(\"screenreaderTrap\", {\n    bubbles: true\n  }));\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAncestors = getAncestors;\nexports.getSiblings = getSiblings;\nexports.getSiblingsOfAncestors = getSiblingsOfAncestors;\n// filter function for ancestor elements\nconst filterAncestor = item => item.nodeType === 1 && item.tagName.toLowerCase() !== \"body\" && item.tagName.toLowerCase() !== \"html\";\n\n// filter function for sibling elements\nconst filterSibling = item => item.nodeType === 1 && item.tagName.toLowerCase() !== \"script\";\n\n// reducer to flatten arrays\nconst flattenArrays = (a, b) => a.concat(b);\n\n// recursive function to get previous sibling nodes of given element\nfunction getPreviousSiblings(el) {\n  let siblings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const previousSibling = el.previousSibling;\n  if (!previousSibling) {\n    return siblings;\n  }\n  siblings.push(previousSibling);\n  return getPreviousSiblings(previousSibling, siblings);\n}\n\n// recursive function to get next sibling nodes of given element\nfunction getNextSiblings(el) {\n  let siblings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const nextSibling = el.nextSibling;\n  if (!nextSibling) {\n    return siblings;\n  }\n  siblings.push(nextSibling);\n  return getNextSiblings(nextSibling, siblings);\n}\n\n// returns all sibling element nodes of given element\nfunction getSiblings(el) {\n  const allSiblings = getPreviousSiblings(el).concat(getNextSiblings(el));\n  return allSiblings.filter(filterSibling);\n}\n\n// recursive function to get all ancestor nodes of given element\nfunction getAllAncestors(el) {\n  let ancestors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const nextAncestor = el.parentNode;\n  if (!nextAncestor) {\n    return ancestors;\n  }\n  ancestors.push(nextAncestor);\n  return getAllAncestors(nextAncestor, ancestors);\n}\n\n// get ancestor nodes of given element\nfunction getAncestors(el) {\n  return getAllAncestors(el).filter(filterAncestor);\n}\n\n// get siblings of ancestors (i.e. aunts and uncles) of given el\nfunction getSiblingsOfAncestors(el) {\n  return getAncestors(el).map(item => getSiblings(item)).reduce(flattenArrays, []);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\n\nvar screenreaderTrap = _interopRequireWildcard(require(\"makeup-screenreader-trap\"));\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\n// REQUIRE\n// const screenreaderTrap = require('makeup-screenreader-trap');\n\n// IMPORT\n\ndocument.querySelectorAll(\".trap\").forEach(function (item) {\n  item.addEventListener(\"click\", function () {\n    if (this.getAttribute(\"aria-pressed\") === \"true\") {\n      screenreaderTrap.untrap(this);\n    } else {\n      screenreaderTrap.trap(this, {\n        useHiddenProperty: false\n      });\n    }\n  });\n  item.addEventListener(\"screenreaderTrap\", function (e) {\n    console.log(this, e);\n    this.innerText = \"Untrap\";\n    this.setAttribute(\"aria-pressed\", \"true\");\n  });\n  item.addEventListener(\"screenreaderUntrap\", function (e) {\n    console.log(this, e);\n    this.innerText = \"Trap\";\n    this.setAttribute(\"aria-pressed\", \"false\");\n  });\n});\ndocument.addEventListener(\"screenreaderTrap\", function (e) {\n  console.log(this, e);\n});\ndocument.addEventListener(\"screenreaderUntrap\", function (e) {\n  console.log(this, e);\n});"],"names":[],"sourceRoot":""}