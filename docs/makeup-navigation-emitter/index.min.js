/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 1390:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createLinear": function() { return /* binding */ createLinear; }
/* harmony export */ });
/* harmony import */ var makeup_key_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4614);
/* harmony import */ var makeup_exit_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3270);


const dataSetKey = "data-makeup-index";
const defaultOptions = {
  axis: "both",
  autoInit: 0,
  autoReset: null,
  ignoreButtons: false,
  wrap: false
};
const itemFilter = (el) => !el.hidden;
function clearData(els) {
  els.forEach((el) => el.removeAttribute(dataSetKey));
}
function setData(els) {
  els.forEach((el, index) => el.setAttribute(dataSetKey, index));
}
function isButton(el) {
  return el.tagName.toLowerCase() === "button" || el.type === "button";
}
function onKeyPrev(e) {
  if (isButton(e.detail.target) === false || this.options.ignoreButtons === false) {
    if (!this.atStart()) {
      this.index--;
    } else if (this.options.wrap) {
      this.index = this.filteredItems.length - 1;
    }
  }
}
function onKeyNext(e) {
  if (isButton(e.detail.target) === false || this.options.ignoreButtons === false) {
    if (!this.atEnd()) {
      this.index++;
    } else if (this.options.wrap) {
      this.index = 0;
    }
  }
}
function onClick(e) {
  let element = e.target;
  let indexData = element.dataset.makeupIndex;
  while (element !== this._el && !indexData) {
    element = element.parentNode;
    indexData = element.dataset.makeupIndex;
  }
  if (indexData !== void 0) {
    this.index = indexData;
  }
}
function onKeyHome(e) {
  if (isButton(e.detail.target) === false || this.options.ignoreButtons === false) {
    this.index = 0;
  }
}
function onKeyEnd(e) {
  if (isButton(e.detail.target) === false || this.options.ignoreButtons === false) {
    this.index = this.filteredItems.length;
  }
}
function onFocusExit() {
  if (this.options.autoReset !== null) {
    this.reset();
  }
}
function onMutation() {
  clearData(this.items);
  setData(this.filteredItems);
  this._el.dispatchEvent(new CustomEvent("navigationModelMutation"));
}
class NavigationModel {
  constructor(el, itemSelector, selectedOptions) {
    this.options = Object.assign({}, defaultOptions, selectedOptions);
    this._el = el;
    this._itemSelector = itemSelector;
  }
}
class LinearNavigationModel extends NavigationModel {
  constructor(el, itemSelector, selectedOptions) {
    super(el, itemSelector, selectedOptions);
    if (this.options.autoInit !== null) {
      this._index = this.options.autoInit;
      this._el.dispatchEvent(new CustomEvent("navigationModelInit", {
        detail: {
          items: this.filteredItems,
          toIndex: this.options.autoInit
        },
        bubbles: false
      }));
    }
  }
  get items() {
    return this._el.querySelectorAll(this._itemSelector);
  }
  get filteredItems() {
    return Array.prototype.slice.call(this.items).filter(itemFilter);
  }
  get index() {
    return this._index;
  }
  set index(newIndex) {
    if (newIndex > -1 && newIndex < this.filteredItems.length && newIndex !== this.index) {
      this._el.dispatchEvent(new CustomEvent("navigationModelChange", {
        detail: {
          fromIndex: this.index,
          toIndex: newIndex
        },
        bubbles: false
      }));
      this._index = newIndex;
    }
  }
  reset() {
    if (this.options.autoReset !== null) {
      this._index = this.options.autoReset;
      this._el.dispatchEvent(new CustomEvent("navigationModelReset", {
        detail: {
          toIndex: this.options.autoReset
        },
        bubbles: false
      }));
    }
  }
  atEnd() {
    return this.index === this.filteredItems.length - 1;
  }
  atStart() {
    return this.index <= 0;
  }
}
class NavigationEmitter {
  constructor(el, model) {
    this.model = model;
    this.el = el;
    this._keyPrevListener = onKeyPrev.bind(model);
    this._keyNextListener = onKeyNext.bind(model);
    this._keyHomeListener = onKeyHome.bind(model);
    this._keyEndListener = onKeyEnd.bind(model);
    this._clickListener = onClick.bind(model);
    this._focusExitListener = onFocusExit.bind(model);
    this._observer = new MutationObserver(onMutation.bind(model));
    setData(model.filteredItems);
    makeup_key_emitter__WEBPACK_IMPORTED_MODULE_1__/* .addKeyDown */ .WA(this.el);
    makeup_exit_emitter__WEBPACK_IMPORTED_MODULE_0__/* .addFocusExit */ .c(this.el);
    const axis = model.options.axis;
    if (axis === "both" || axis === "x") {
      this.el.addEventListener("arrowLeftKeyDown", this._keyPrevListener);
      this.el.addEventListener("arrowRightKeyDown", this._keyNextListener);
    }
    if (axis === "both" || axis === "y") {
      this.el.addEventListener("arrowUpKeyDown", this._keyPrevListener);
      this.el.addEventListener("arrowDownKeyDown", this._keyNextListener);
    }
    this.el.addEventListener("homeKeyDown", this._keyHomeListener);
    this.el.addEventListener("endKeyDown", this._keyEndListener);
    this.el.addEventListener("click", this._clickListener);
    this.el.addEventListener("focusExit", this._focusExitListener);
    this._observer.observe(this.el, {
      childList: true,
      subtree: true,
      attributeFilter: ["hidden"],
      attributes: true
    });
  }
  destroy() {
    makeup_key_emitter__WEBPACK_IMPORTED_MODULE_1__/* .removeKeyDown */ .hv(this.el);
    makeup_exit_emitter__WEBPACK_IMPORTED_MODULE_0__/* .removeFocusExit */ .G(this.el);
    this.el.removeEventListener("arrowLeftKeyDown", this._keyPrevListener);
    this.el.removeEventListener("arrowRightKeyDown", this._keyNextListener);
    this.el.removeEventListener("arrowUpKeyDown", this._keyPrevListener);
    this.el.removeEventListener("arrowDownKeyDown", this._keyNextListener);
    this.el.removeEventListener("homeKeyDown", this._keyHomeListener);
    this.el.removeEventListener("endKeyDown", this._keyEndListener);
    this.el.removeEventListener("click", this._clickListener);
    this.el.removeEventListener("focusExit", this._focusExitListener);
    this._observer.disconnect();
  }
}
function createLinear(el, itemSelector, selectedOptions) {
  const model = new LinearNavigationModel(el, itemSelector, selectedOptions);
  return new NavigationEmitter(el, model);
}



/***/ }),

/***/ 3270:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": function() { return /* binding */ addFocusExit; },
/* harmony export */   "G": function() { return /* binding */ removeFocusExit; }
/* harmony export */ });
/* harmony import */ var makeup_next_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7492);

const focusExitEmitters = {};
function doFocusExit(el, fromElement, toElement) {
  el.dispatchEvent(new CustomEvent("focusExit", {
    detail: { fromElement, toElement },
    bubbles: false
  }));
}
function onDocumentFocusIn(e) {
  const newFocusElement = e.target;
  const targetIsDescendant = this.el.contains(newFocusElement);
  if (targetIsDescendant === true) {
    this.currentFocusElement = newFocusElement;
  } else {
    window.removeEventListener("blur", this.onWindowBlurListener);
    document.removeEventListener("focusin", this.onDocumentFocusInListener);
    doFocusExit(this.el, this.currentFocusElement, newFocusElement);
    this.currentFocusElement = null;
  }
}
function onWindowBlur() {
  doFocusExit(this.el, this.currentFocusElement, void 0);
}
function onWidgetFocusIn() {
  document.addEventListener("focusin", this.onDocumentFocusInListener);
  window.addEventListener("blur", this.onWindowBlurListener);
}
class FocusExitEmitter {
  constructor(el) {
    this.el = el;
    this.currentFocusElement = null;
    this.onWidgetFocusInListener = onWidgetFocusIn.bind(this);
    this.onDocumentFocusInListener = onDocumentFocusIn.bind(this);
    this.onWindowBlurListener = onWindowBlur.bind(this);
    this.el.addEventListener("focusin", this.onWidgetFocusInListener);
  }
  removeEventListeners() {
    window.removeEventListener("blur", this.onWindowBlurListener);
    document.removeEventListener("focusin", this.onDocumentFocusInListener);
    this.el.removeEventListener("focusin", this.onWidgetFocusInListener);
  }
}
function addFocusExit(el) {
  let exitEmitter = null;
  (0,makeup_next_id__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(el);
  if (!focusExitEmitters[el.id]) {
    exitEmitter = new FocusExitEmitter(el);
    focusExitEmitters[el.id] = exitEmitter;
  }
  return exitEmitter;
}
function removeFocusExit(el) {
  const exitEmitter = focusExitEmitters[el.id];
  if (exitEmitter) {
    exitEmitter.removeEventListeners();
    delete focusExitEmitters[el.id];
  }
}



/***/ }),

/***/ 4614:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WA": function() { return /* binding */ addKeyDown; },
/* harmony export */   "hv": function() { return /* binding */ removeKeyDown; }
/* harmony export */ });
/* unused harmony exports add, addKeyUp, remove, removeKeyUp */
function uncapitalizeFirstLetter(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}
function onKeyDownOrUp(evt, el, keyEventType) {
  if (!evt.shiftKey) {
    const key = evt.key;
    switch (key) {
      case "Enter":
      case "Escape":
      case "PageUp":
      case "PageDown":
      case "End":
      case "Home":
      case "ArrowLeft":
      case "ArrowUp":
      case "ArrowRight":
      case "ArrowDown":
        el.dispatchEvent(new CustomEvent(uncapitalizeFirstLetter(`${key}Key${keyEventType}`), {
          detail: evt,
          bubbles: true
        }));
        break;
      case " ":
        el.dispatchEvent(new CustomEvent(`spacebarKey${keyEventType}`, {
          detail: evt,
          bubbles: true
        }));
        break;
      default:
        return;
    }
  }
}
function onKeyDown(e) {
  onKeyDownOrUp(e, this, "Down");
}
function onKeyUp(e) {
  onKeyDownOrUp(e, this, "Up");
}
function addKeyDown(el) {
  el.addEventListener("keydown", onKeyDown);
}
function addKeyUp(el) {
  el.addEventListener("keyup", onKeyUp);
}
function removeKeyDown(el) {
  el.removeEventListener("keydown", onKeyDown);
}
function removeKeyUp(el) {
  el.removeEventListener("keyup", onKeyUp);
}
function add(el) {
  addKeyDown(el);
  addKeyUp(el);
}
function remove(el) {
  removeKeyDown(el);
  removeKeyUp(el);
}



/***/ }),

/***/ 7492:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": function() { return /* binding */ src_default; }
/* harmony export */ });
const sequenceMap = {};
const defaultPrefix = "nid";
const randomPortion = createRandomPortion(3);
function randomNumber(max) {
  return Math.floor(Math.random() * max);
}
function createRandomPortion(size) {
  const letters = "abcdefghijklmnopqrstuvwxyz";
  const digits = "0123456789";
  const allChars = letters + digits;
  let portion = letters[randomNumber(25)];
  for (let i = 1; i < size; i++) {
    portion += allChars[randomNumber(35)];
  }
  return portion;
}
function src_default(el, prefix = defaultPrefix) {
  const separator = prefix === "" ? "" : "-";
  const key = `${prefix}${separator}${randomPortion}`;
  sequenceMap[key] = sequenceMap[key] || 0;
  if (!el.id) {
    el.setAttribute("id", `${key}-${sequenceMap[key]++}`);
  }
  return el.id;
}



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {


var NavigationEmitter = _interopRequireWildcard(__webpack_require__(1390));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// REQUIRE
//const NavigationEmitter = require('../../packages/makeup-navigation-emitter');
// IMPORT
var emitters = [];
var appender = document.getElementById('appender');
var widgetEls = document.querySelectorAll('.widget');
var consoleEls = document.querySelectorAll('.console');
var wrapCheckbox = document.getElementById('wrap');
var options = [{}, {
  autoInit: -1,
  autoReset: -1
}, {
  autoInit: -1,
  autoReset: -1
}];
appender.addEventListener('click', function () {
  widgetEls.forEach(function (el) {
    var listEl = el.querySelector('ul');
    var listItem = document.createElement('li');
    listItem.innerText = "Item ".concat(parseInt(listEl.querySelectorAll('li').length, 10));
    listEl.appendChild(listItem);
  });
});
widgetEls.forEach(function (el, index) {
  el.addEventListener('navigationModelInit', function (e) {
    consoleEls[index].value = e.detail.toIndex;
  });
  el.addEventListener('navigationModelChange', function (e) {
    consoleEls[index].value = e.detail.toIndex;
  });
  el.addEventListener('navigationModelReset', function (e) {
    consoleEls[index].value = e.detail.toIndex;
  });
  emitters.push(NavigationEmitter.createLinear(el, 'li', options[index]));
});
wrapCheckbox.addEventListener('change', function (e) {
  emitters.forEach(function (emitter) {
    emitter.model.options.wrap = e.target.checked;
  });
}); // emitters[0].model.index = 1;
// emitters[1].model.index = 1;
}();
/******/ })()
;
//# sourceMappingURL=index.min.js.map