/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 5015:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(1381);


/***/ }),

/***/ 7672:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(2491);


/***/ }),

/***/ 4658:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(8481);
__webpack_require__(3540);


/***/ }),

/***/ 8481:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(9357);


/***/ }),

/***/ 3540:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(2002);


/***/ }),

/***/ 7098:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(3981);


/***/ }),

/***/ 5957:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 1381:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 2491:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 9357:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 2002:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 3981:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 4739:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ src_default)
});

;// CONCATENATED MODULE: ./packages/makeup-next-id/dist/mjs/index.js
const sequenceMap = {};
const defaultPrefix = "nid";
const randomPortion = createRandomPortion(3);
function randomNumber(max) {
  return Math.floor(Math.random() * max);
}
function createRandomPortion(size) {
  const letters = "abcdefghijklmnopqrstuvwxyz";
  const digits = "0123456789";
  const allChars = letters + digits;
  let portion = letters[randomNumber(25)];
  for (let i = 1; i < size; i++) {
    portion += allChars[randomNumber(35)];
  }
  return portion;
}
function mjs_src_default(el, prefix = defaultPrefix) {
  const separator = prefix === "" ? "" : "-";
  const key = `${prefix}${separator}${randomPortion}`;
  sequenceMap[key] = sequenceMap[key] || 0;
  if (!el.id) {
    el.setAttribute("id", `${key}-${sequenceMap[key]++}`);
  }
  return el.id;
}


;// CONCATENATED MODULE: ./packages/makeup-key-emitter/dist/mjs/index.js
function uncapitalizeFirstLetter(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}
function onKeyDownOrUp(evt, el, keyEventType) {
  if (!evt.shiftKey) {
    const key = evt.key;
    switch (key) {
      case "Enter":
      case "Escape":
      case "PageUp":
      case "PageDown":
      case "End":
      case "Home":
      case "ArrowLeft":
      case "ArrowUp":
      case "ArrowRight":
      case "ArrowDown":
        el.dispatchEvent(
          new CustomEvent(uncapitalizeFirstLetter(`${key}Key${keyEventType}`), {
            detail: evt,
            bubbles: true
          })
        );
        break;
      case " ":
        el.dispatchEvent(
          new CustomEvent(`spacebarKey${keyEventType}`, {
            detail: evt,
            bubbles: true
          })
        );
        break;
      default:
        return;
    }
  }
}
function onKeyDown(e) {
  onKeyDownOrUp(e, this, "Down");
}
function onKeyUp(e) {
  onKeyDownOrUp(e, this, "Up");
}
function addKeyDown(el) {
  el.addEventListener("keydown", onKeyDown);
}
function addKeyUp(el) {
  el.addEventListener("keyup", onKeyUp);
}
function removeKeyDown(el) {
  el.removeEventListener("keydown", onKeyDown);
}
function removeKeyUp(el) {
  el.removeEventListener("keyup", onKeyUp);
}
function add(el) {
  addKeyDown(el);
  addKeyUp(el);
}
function remove(el) {
  removeKeyDown(el);
  removeKeyUp(el);
}


;// CONCATENATED MODULE: ./packages/makeup-exit-emitter/dist/mjs/index.js

const focusExitEmitters = {};
function doFocusExit(el, fromElement, toElement) {
  el.dispatchEvent(
    new CustomEvent("focusExit", {
      detail: { fromElement, toElement },
      bubbles: false
      // mirror the native mouseleave event
    })
  );
}
function onDocumentFocusIn(e) {
  const newFocusElement = e.target;
  const targetIsDescendant = this.el.contains(newFocusElement);
  if (targetIsDescendant === true) {
    this.currentFocusElement = newFocusElement;
  } else {
    window.removeEventListener("blur", this.onWindowBlurListener);
    document.removeEventListener("focusin", this.onDocumentFocusInListener);
    doFocusExit(this.el, this.currentFocusElement, newFocusElement);
    this.currentFocusElement = null;
  }
}
function onWindowBlur() {
  doFocusExit(this.el, this.currentFocusElement, void 0);
}
function onWidgetFocusIn() {
  document.addEventListener("focusin", this.onDocumentFocusInListener);
  window.addEventListener("blur", this.onWindowBlurListener);
}
class FocusExitEmitter {
  constructor(el) {
    this.el = el;
    this.currentFocusElement = null;
    this.onWidgetFocusInListener = onWidgetFocusIn.bind(this);
    this.onDocumentFocusInListener = onDocumentFocusIn.bind(this);
    this.onWindowBlurListener = onWindowBlur.bind(this);
    this.el.addEventListener("focusin", this.onWidgetFocusInListener);
  }
  removeEventListeners() {
    window.removeEventListener("blur", this.onWindowBlurListener);
    document.removeEventListener("focusin", this.onDocumentFocusInListener);
    this.el.removeEventListener("focusin", this.onWidgetFocusInListener);
  }
}
function addFocusExit(el) {
  let exitEmitter = null;
  mjs_src_default(el);
  if (!focusExitEmitters[el.id]) {
    exitEmitter = new FocusExitEmitter(el);
    focusExitEmitters[el.id] = exitEmitter;
  }
  return exitEmitter;
}
function removeFocusExit(el) {
  const exitEmitter = focusExitEmitters[el.id];
  if (exitEmitter) {
    exitEmitter.removeEventListeners();
    delete focusExitEmitters[el.id];
  }
}


;// CONCATENATED MODULE: ./packages/makeup-navigation-emitter/dist/mjs/index.js


const defaultOptions = {
  axis: "both",
  autoInit: "interactive",
  autoReset: "current",
  ignoreByDelegateSelector: null,
  wrap: false
};
function isItemNavigable(el) {
  return !el.hidden && el.getAttribute("aria-disabled") !== "true";
}
function isIndexNavigable(items, index) {
  return index >= 0 && index < items.length ? isItemNavigable(items[index]) : false;
}
function findNavigableItems(items) {
  return items.filter(isItemNavigable);
}
function findFirstNavigableIndex(items) {
  return items.findIndex((item) => isItemNavigable(item));
}
function findLastNavigableIndex(items) {
  return items.indexOf(findNavigableItems(items).reverse()[0]);
}
function findIndexByAttribute(items, attribute, value) {
  return items.findIndex((item) => isItemNavigable(item) && item.getAttribute(attribute) === value);
}
function findFirstNavigableAriaCheckedIndex(items) {
  return findIndexByAttribute(items, "aria-checked", "true");
}
function findFirstNavigableAriaSelectedIndex(items) {
  return findIndexByAttribute(items, "aria-selected", "true");
}
function findIgnoredByDelegateItems(el, options) {
  return options.ignoreByDelegateSelector !== null ? [...el.querySelectorAll(options.ignoreByDelegateSelector)] : [];
}
function findPreviousNavigableIndex(items, index, wrap) {
  let previousNavigableIndex = -1;
  if (index === null || atStart(items, index)) {
    if (wrap === true) {
      previousNavigableIndex = findLastNavigableIndex(items);
    }
  } else {
    let i = index;
    while (--i >= 0) {
      if (isItemNavigable(items[i])) {
        previousNavigableIndex = i;
        break;
      }
    }
  }
  return previousNavigableIndex;
}
function findNextNavigableIndex(items, index, wrap) {
  let nextNavigableIndex = -1;
  if (index === null) {
    nextNavigableIndex = findFirstNavigableIndex(items);
  } else if (atEnd(items, index)) {
    if (wrap === true) {
      nextNavigableIndex = findFirstNavigableIndex(items);
    }
  } else {
    let i = index;
    while (++i < items.length) {
      if (isItemNavigable(items[i])) {
        nextNavigableIndex = i;
        break;
      }
    }
  }
  return nextNavigableIndex;
}
function findIndexPositionByType(typeOrNum, items, currentIndex) {
  let index = -1;
  switch (typeOrNum) {
    case "none":
      index = null;
      break;
    case "current":
      index = currentIndex;
      break;
    case "interactive":
      index = findFirstNavigableIndex(items);
      break;
    case "ariaChecked":
      index = findFirstNavigableAriaCheckedIndex(items);
      break;
    case "ariaSelected":
      index = findFirstNavigableAriaSelectedIndex(items);
      break;
    case "ariaSelectedOrInteractive":
      index = findFirstNavigableAriaSelectedIndex(items);
      index = index === -1 ? findFirstNavigableIndex(items) : index;
      break;
    default:
      index = typeof typeOrNum === "number" || typeOrNum === null ? typeOrNum : -1;
  }
  return index;
}
function atStart(items, index) {
  return index === findFirstNavigableIndex(items);
}
function atEnd(items, index) {
  return index === findLastNavigableIndex(items);
}
function onKeyPrev(e) {
  const ignoredByDelegateItems = findIgnoredByDelegateItems(this._el, this.options);
  if (ignoredByDelegateItems.length === 0 || !ignoredByDelegateItems.includes(e.detail.target)) {
    this.index = findPreviousNavigableIndex(this.items, this.index, this.options.wrap);
  }
}
function onKeyNext(e) {
  const ignoredByDelegateItems = findIgnoredByDelegateItems(this._el, this.options);
  if (ignoredByDelegateItems.length === 0 || !ignoredByDelegateItems.includes(e.detail.target)) {
    this.index = findNextNavigableIndex(this.items, this.index, this.options.wrap);
  }
}
function onClick(e) {
  const itemIndex = this.indexOf(e.target.closest(this._itemSelector));
  if (isIndexNavigable(this.items, itemIndex)) {
    this.index = itemIndex;
  }
}
function onKeyHome(e) {
  const ignoredByDelegateItems = findIgnoredByDelegateItems(this._el, this.options);
  if (ignoredByDelegateItems.length === 0 || !ignoredByDelegateItems.includes(e.detail.target)) {
    this.index = findFirstNavigableIndex(this.items);
  }
}
function onKeyEnd(e) {
  const ignoredByDelegateItems = findIgnoredByDelegateItems(this._el, this.options);
  if (ignoredByDelegateItems.length === 0 || !ignoredByDelegateItems.includes(e.detail.target)) {
    this.index = findLastNavigableIndex(this.items);
  }
}
function onFocusExit() {
  if (this.options.autoReset !== null) {
    this.reset();
  }
}
function onMutation(e) {
  const fromIndex = this.index;
  let toIndex = this.index;
  const { addedNodes, attributeName, removedNodes, target, type } = e[0];
  if (type === "attributes") {
    if (target === this.currentItem) {
      if (attributeName === "aria-disabled") {
        toIndex = this.index;
      } else if (attributeName === "hidden") {
        toIndex = findFirstNavigableIndex(this.items);
      }
    } else {
      toIndex = this.index;
    }
  } else if (type === "childList") {
    if (removedNodes.length > 0 && [...removedNodes].includes(this._cachedElement)) {
      toIndex = findFirstNavigableIndex(this.items);
    } else if (removedNodes.length > 0 || addedNodes.length > 0) {
      toIndex = this.indexOf(this._cachedElement);
    }
  }
  this._index = toIndex;
  this._el.dispatchEvent(
    new CustomEvent("navigationModelMutation", {
      bubbles: false,
      detail: { fromIndex, toIndex }
    })
  );
}
class NavigationModel {
  /**
   * @param {HTMLElement} el
   * @param {string} itemSelector
   * @param {typeof defaultOptions} selectedOptions
   */
  constructor(el, itemSelector, selectedOptions) {
    this.options = Object.assign({}, defaultOptions, selectedOptions);
    this._el = el;
    this._itemSelector = itemSelector;
  }
}
class LinearNavigationModel extends NavigationModel {
  /**
   * @param {HTMLElement} el
   * @param {string} itemSelector
   * @param {typeof defaultOptions} selectedOptions
   */
  constructor(el, itemSelector, selectedOptions) {
    super(el, itemSelector, selectedOptions);
    const fromIndex = this._index;
    const toIndex = findIndexPositionByType(this.options.autoInit, this.items, this.index);
    this._index = toIndex;
    this._cachedElement = this.items[toIndex];
    this._el.dispatchEvent(
      new CustomEvent("navigationModelInit", {
        bubbles: false,
        detail: {
          firstInteractiveIndex: this.firstNavigableIndex,
          fromIndex,
          items: this.items,
          toIndex
        }
      })
    );
  }
  get currentItem() {
    return this.items[this.index];
  }
  // todo: code smell as getter abstracts that the query selector re-runs every time getter is accessed
  get items() {
    return [...this._el.querySelectorAll(`${this._itemSelector}`)];
  }
  get index() {
    return this._index;
  }
  /**
   * @param {number} toIndex - update index position in this.items (non-interactive indexes fail silently)
   */
  set index(toIndex) {
    if (toIndex === this.index) {
      return;
    } else if (!isIndexNavigable(this.items, toIndex)) {
    } else {
      const fromIndex = this.index;
      this._cachedElement = this.items[toIndex];
      this._index = toIndex;
      this._el.dispatchEvent(
        new CustomEvent("navigationModelChange", {
          bubbles: false,
          detail: { fromIndex, toIndex }
        })
      );
    }
  }
  indexOf(element) {
    return this.items.indexOf(element);
  }
  reset() {
    const fromIndex = this.index;
    const toIndex = findIndexPositionByType(this.options.autoReset, this.items, this.index);
    if (toIndex !== fromIndex) {
      this._index = toIndex;
      this._el.dispatchEvent(
        new CustomEvent("navigationModelReset", {
          bubbles: false,
          detail: { fromIndex, toIndex }
        })
      );
    }
  }
}
class NavigationEmitter {
  /**
   * @param {HTMLElement} el
   * @param {LinearNavigationModel} model
   */
  constructor(el, model) {
    this.model = model;
    this.el = el;
    this._keyPrevListener = onKeyPrev.bind(model);
    this._keyNextListener = onKeyNext.bind(model);
    this._keyHomeListener = onKeyHome.bind(model);
    this._keyEndListener = onKeyEnd.bind(model);
    this._clickListener = onClick.bind(model);
    this._focusExitListener = onFocusExit.bind(model);
    this._observer = new MutationObserver(onMutation.bind(model));
    addKeyDown(this.el);
    addFocusExit(this.el);
    const axis = model.options.axis;
    if (axis === "both" || axis === "x") {
      this.el.addEventListener("arrowLeftKeyDown", this._keyPrevListener);
      this.el.addEventListener("arrowRightKeyDown", this._keyNextListener);
    }
    if (axis === "both" || axis === "y") {
      this.el.addEventListener("arrowUpKeyDown", this._keyPrevListener);
      this.el.addEventListener("arrowDownKeyDown", this._keyNextListener);
    }
    this.el.addEventListener("homeKeyDown", this._keyHomeListener);
    this.el.addEventListener("endKeyDown", this._keyEndListener);
    this.el.addEventListener("click", this._clickListener);
    this.el.addEventListener("focusExit", this._focusExitListener);
    this._observer.observe(this.el, {
      childList: true,
      subtree: true,
      attributeFilter: ["aria-disabled", "hidden"],
      attributes: true,
      attributeOldValue: true
    });
  }
  destroy() {
    removeKeyDown(this.el);
    removeFocusExit(this.el);
    this.el.removeEventListener("arrowLeftKeyDown", this._keyPrevListener);
    this.el.removeEventListener("arrowRightKeyDown", this._keyNextListener);
    this.el.removeEventListener("arrowUpKeyDown", this._keyPrevListener);
    this.el.removeEventListener("arrowDownKeyDown", this._keyNextListener);
    this.el.removeEventListener("homeKeyDown", this._keyHomeListener);
    this.el.removeEventListener("endKeyDown", this._keyEndListener);
    this.el.removeEventListener("click", this._clickListener);
    this.el.removeEventListener("focusExit", this._focusExitListener);
    this._observer.disconnect();
  }
}
function createLinear(el, itemSelector, selectedOptions) {
  const model = new LinearNavigationModel(el, itemSelector, selectedOptions);
  return new NavigationEmitter(el, model);
}


;// CONCATENATED MODULE: ./packages/makeup-roving-tabindex/dist/mjs/index.js

const mjs_defaultOptions = {
  autoInit: "interactive",
  autoReset: "current",
  wrap: false,
  axis: "both"
};
function refreshTabindex(items, focusIndex) {
  items.forEach(function(el, i) {
    el.setAttribute("tabindex", i === focusIndex ? "0" : "-1");
  });
}
function onModelInit(e) {
  refreshTabindex(e.detail.items, e.detail.toIndex);
  this._el.dispatchEvent(new CustomEvent("rovingTabindexInit", { detail: e.detail }));
}
function onModelChange(e) {
  const items = this.items;
  const fromItem = items[e.detail.fromIndex];
  const toItem = items[e.detail.toIndex];
  if (fromItem) {
    fromItem.setAttribute("tabindex", "-1");
  }
  if (toItem) {
    toItem.setAttribute("tabindex", "0");
    toItem.focus();
  }
  this._el.dispatchEvent(new CustomEvent("rovingTabindexChange", { detail: e.detail }));
}
function onModelReset(e) {
  refreshTabindex(this.items, e.detail.toIndex);
  this._el.dispatchEvent(new CustomEvent("rovingTabindexReset", { detail: e.detail }));
}
function onModelMutation(e) {
  refreshTabindex(this.items, e.detail.toIndex);
  this._el.dispatchEvent(new CustomEvent("rovingTabindexMutation", { detail: e.detail }));
}
class RovingTabindex {
  constructor(el) {
    this._el = el;
    this._onMutationListener = onModelMutation.bind(this);
    this._onChangeListener = onModelChange.bind(this);
    this._onInitListener = onModelInit.bind(this);
    this._onResetListener = onModelReset.bind(this);
    this._el.addEventListener("navigationModelMutation", this._onMutationListener);
    this._el.addEventListener("navigationModelChange", this._onChangeListener);
    this._el.addEventListener("navigationModelInit", this._onInitListener);
    this._el.addEventListener("navigationModelReset", this._onResetListener);
  }
  destroy() {
    this._el.removeEventListener("navigationModelMutation", this._onMutationListener);
    this._el.removeEventListener("navigationModelChange", this._onChangeListener);
    this._el.removeEventListener("navigationModelInit", this._onInitListener);
    this._el.removeEventListener("navigationModelReset", this._onResetListener);
  }
}
class LinearRovingTabindex extends RovingTabindex {
  constructor(el, itemSelector, selectedOptions) {
    super(el);
    this._options = Object.assign({}, mjs_defaultOptions, selectedOptions);
    this._itemSelector = itemSelector;
    this._navigationEmitter = createLinear(el, itemSelector, {
      autoInit: this._options.index !== void 0 ? this._options.index : this._options.autoInit,
      autoReset: this._options.autoReset,
      wrap: this._options.wrap,
      axis: this._options.axis
    });
  }
  get index() {
    return this._navigationEmitter.model.index;
  }
  set index(newIndex) {
    this._navigationEmitter.model.index = newIndex;
  }
  set wrap(newWrap) {
    this._navigationEmitter.model.options.wrap = newWrap;
  }
  get currentItem() {
    return this._navigationEmitter.model.currentItem;
  }
  get items() {
    return this._navigationEmitter.model.items;
  }
  reset() {
    this._navigationEmitter.model.reset();
  }
  destroy() {
    super.destroy();
    this._navigationEmitter.destroy();
  }
}
function mjs_createLinear(el, itemSelector, selectedOptions) {
  return new LinearRovingTabindex(el, itemSelector, selectedOptions);
}


;// CONCATENATED MODULE: ./packages/makeup-prevent-scroll-keys/dist/mjs/index.js
function mjs_onKeyDown(e) {
  if (e.keyCode >= 32 && e.keyCode <= 40) {
    e.preventDefault();
  }
}
function mjs_add(el) {
  el.addEventListener("keydown", mjs_onKeyDown);
}
function mjs_remove(el) {
  el.removeEventListener("keydown", mjs_onKeyDown);
}


;// CONCATENATED MODULE: ./packages/makeup-tabs/dist/mjs/index.js



function linkTabToPanel(widgetID, el, i) {
  el.setAttribute("id", `${widgetID}-tab-${i}`);
  el.setAttribute("aria-controls", `${widgetID}-panel-${i}`);
}
function linkPanelToTab(widgetID, el, i) {
  el.setAttribute("id", `${widgetID}-panel-${i}`);
  el.setAttribute("aria-labelledby", `${widgetID}-tab-${i}`);
}
function disableLink(el) {
  el.setAttribute("role", "presentation");
  el.removeAttribute("href");
}
function dispatchEvent(el, fromIndex, toIndex) {
  el.dispatchEvent(
    new CustomEvent("makeup-tabs-change", {
      detail: {
        fromIndex,
        toIndex
      }
    })
  );
}
function onRovingTabindexChange(e) {
  this.tabs[e.detail.fromIndex].setAttribute("aria-selected", "false");
  this.panels[e.detail.fromIndex].hidden = true;
  this.tabs[e.detail.toIndex].setAttribute("aria-selected", "true");
  this.panels[e.detail.toIndex].hidden = false;
  dispatchEvent(this._el, e.detail.fromIndex, e.detail.toIndex);
}
function onTabListKeyDown(e) {
  if (e.keyCode === 13 || e.keyCode === 32) {
    const fromIndex = this.index;
    const toIndex = [...this.tabs].indexOf(e.target);
    if (fromIndex !== toIndex) {
      this.tabs[fromIndex].setAttribute("aria-selected", "false");
      this.panels[fromIndex].hidden = true;
      this.tabs[toIndex].setAttribute("aria-selected", "true");
      this.panels[toIndex].hidden = false;
      dispatchEvent(this._el, fromIndex, toIndex);
    }
  }
}
function onTabListClick(e) {
  const tabEl = e.target.closest("[role=tab]");
  if (tabEl) {
    const fromIndex = this.index;
    const toIndex = [...this.tabs].indexOf(tabEl);
    if (fromIndex !== toIndex) {
      this.tabs[fromIndex].setAttribute("aria-selected", "false");
      this.panels[fromIndex].hidden = true;
      tabEl.setAttribute("aria-selected", "true");
      this.panels[toIndex].hidden = false;
      dispatchEvent(this._el, fromIndex, toIndex);
    }
  }
}
const dist_mjs_defaultOptions = {
  autoSelect: true,
  initialIndex: 0
};
class src_default {
  constructor(widgetEl, selectedOptions) {
    this._options = Object.assign({}, dist_mjs_defaultOptions, selectedOptions);
    this._onRovingTabindexChangeListener = onRovingTabindexChange.bind(this);
    this._onTabListKeyDownListener = onTabListKeyDown.bind(this);
    this._onTabListClickListener = onTabListClick.bind(this);
    this._el = widgetEl;
    const tabList = this._el.querySelector(".tabs__items");
    const tabs = this._el.querySelectorAll(".tabs__item");
    const panels = this._el.querySelectorAll(".tabs__panel");
    const links = tabList.querySelectorAll("a");
    this.tabList = tabList;
    this.tabs = tabs;
    this.panels = panels;
    let initialIndex = this._options.initialIndex;
    if (initialIndex < 0 || initialIndex >= tabs.length) {
      initialIndex = 0;
    }
    mjs_src_default(widgetEl, "tabs");
    tabList.setAttribute("role", "tablist");
    tabs.forEach((el) => el.setAttribute("role", "tab"));
    panels.forEach((el) => el.setAttribute("role", "tabpanel"));
    tabs[initialIndex].setAttribute("aria-selected", "true");
    [...tabs].filter((el, i) => i !== initialIndex).forEach((el) => el.setAttribute("aria-selected", "false"));
    [...panels].filter((el, i) => i !== initialIndex).forEach((el) => el.hidden = true);
    tabs.forEach((el, i) => linkTabToPanel(this._el.id, el, i));
    panels.forEach((el, i) => linkPanelToTab(this._el.id, el, i));
    links.forEach((el) => disableLink(el));
    this._rovingTabindex = mjs_createLinear(this._el, "[role=tab]", { wrap: true });
    this.wake();
    mjs_add(tabList);
    this._el.classList.add("tabs--js");
  }
  get index() {
    return [...this.tabs].findIndex(function(el) {
      return el.getAttribute("aria-selected") === "true";
    });
  }
  sleep() {
    this._el.removeEventListener("rovingTabindexChange", this._onRovingTabindexChangeListener);
    this.tabList.removeEventListener("keydown", this._onTabListKeyDownListener);
    this.tabList.removeEventListener("click", this._onTabListClickListener);
  }
  wake() {
    if (this._destroyed !== true) {
      if (this._options.autoSelect === true) {
        this._el.addEventListener("rovingTabindexChange", this._onRovingTabindexChangeListener);
      } else {
        this.tabList.addEventListener("keydown", this._onTabListKeyDownListener);
        this.tabList.addEventListener("click", this._onTabListClickListener);
      }
    }
  }
  destroy() {
    this._destroyed = true;
    this.sleep();
    this._onRovingTabindexChangeListener = null;
    this._onTabListKeyDownListener = null;
    this._onTabListClickListener = null;
  }
}



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";


__webpack_require__(5957);
__webpack_require__(4658);
__webpack_require__(5015);
__webpack_require__(7098);
__webpack_require__(7672);
var _makeupTabs = _interopRequireDefault(__webpack_require__(4739));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// REQUIRE
// const Tabs = require('../../packages/makeup-tabs').default;

// IMPORT

const log = e => console.log(e.type, e.detail);
const widgets = [];
window.onload = function () {
  document.querySelectorAll(".tabs").forEach(function (el, i) {
    el.addEventListener("makeup-tabs-change", log);
    widgets.push(new _makeupTabs.default(el, {
      autoSelect: el.dataset.makeupAutoSelect === "false" ? false : true
    }));
  });
};
})();

/******/ })()
;
//# sourceMappingURL=index.min.js.map