/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 2915:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(7417);


/***/ }),

/***/ 5015:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(1381);


/***/ }),

/***/ 4658:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(8481);
__webpack_require__(3540);


/***/ }),

/***/ 8481:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(9357);


/***/ }),

/***/ 3540:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(2002);


/***/ }),

/***/ 5957:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 7417:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 1381:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 9357:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 2002:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 2960:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createLinear = createLinear;
var NavigationEmitter = _interopRequireWildcard(__webpack_require__(8405));
var _makeupNextId = _interopRequireDefault(__webpack_require__(3937));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const defaultOptions = {
  activeDescendantClassName: "active-descendant",
  autoInit: "none",
  autoReset: "none",
  autoScroll: false,
  axis: "both",
  wrap: false
};
function onModelInit(e) {
  const {
    items,
    toIndex
  } = e.detail;
  const itemEl = items[toIndex];
  if (itemEl) {
    itemEl.classList.add(this._options.activeDescendantClassName);
    this._focusEl.setAttribute("aria-activedescendant", itemEl.id);
  }
  this._el.dispatchEvent(new CustomEvent("activeDescendantInit", {
    detail: e.detail
  }));
}
function onModelChange(e) {
  const {
    fromIndex,
    toIndex
  } = e.detail;
  const fromItem = this.items[fromIndex];
  const toItem = this.items[toIndex];
  if (fromItem) {
    fromItem.classList.remove(this._options.activeDescendantClassName);
  }
  if (toItem) {
    toItem.classList.add(this._options.activeDescendantClassName);
    this._focusEl.setAttribute("aria-activedescendant", toItem.id);
    if (this._options.autoScroll && this._itemContainerEl) {
      toItem.scrollIntoView({
        block: "center"
      });
    }
  }
  this._el.dispatchEvent(new CustomEvent("activeDescendantChange", {
    detail: e.detail
  }));
}
function onModelReset(e) {
  const toIndex = e.detail.toIndex;
  const activeClassName = this._options.activeDescendantClassName;
  this.items.forEach(function (el) {
    el.classList.remove(activeClassName);
  });
  if (toIndex !== null && toIndex !== -1) {
    const itemEl = this.items[toIndex];
    itemEl.classList.add(activeClassName);
    this._focusEl.setAttribute("aria-activedescendant", itemEl.id);
  } else {
    this._focusEl.removeAttribute("aria-activedescendant");
  }
  this._el.dispatchEvent(new CustomEvent("activeDescendantReset", {
    detail: e.detail
  }));
}
function onModelMutation(e) {
  const {
    toIndex
  } = e.detail;
  const activeDescendantClassName = this._options.activeDescendantClassName;
  this.items.forEach(function (item, index) {
    (0, _makeupNextId.default)(item);
    if (index !== toIndex) {
      item.classList.remove(activeDescendantClassName);
    } else {
      item.classList.add(activeDescendantClassName);
    }
  });
  this._el.dispatchEvent(new CustomEvent("activeDescendantMutation", {
    detail: e.detail
  }));
}
class ActiveDescendant {
  constructor(el) {
    this._el = el;
    this._onMutationListener = onModelMutation.bind(this);
    this._onChangeListener = onModelChange.bind(this);
    this._onResetListener = onModelReset.bind(this);
    this._onInitListener = onModelInit.bind(this);
    this._el.addEventListener("navigationModelMutation", this._onMutationListener);
    this._el.addEventListener("navigationModelChange", this._onChangeListener);
    this._el.addEventListener("navigationModelReset", this._onResetListener);
    this._el.addEventListener("navigationModelInit", this._onInitListener);
  }
  destroy() {
    this._el.removeEventListener("navigationModelMutation", this._onMutationListener);
    this._el.removeEventListener("navigationModelChange", this._onChangeListener);
    this._el.removeEventListener("navigationModelReset", this._onResetListener);
    this._el.removeEventListener("navigationModelInit", this._onInitListener);
  }
}
class LinearActiveDescendant extends ActiveDescendant {
  constructor(el, focusEl, itemContainerEl, itemSelector, selectedOptions) {
    super(el);
    this._options = Object.assign({}, defaultOptions, selectedOptions);
    this._focusEl = focusEl;
    this._itemContainerEl = itemContainerEl;
    this._itemSelector = itemSelector;

    // ensure container has an id
    (0, _makeupNextId.default)(this._itemContainerEl);

    // if programmatic relationship set aria-owns
    if (this._itemContainerEl !== this._focusEl) {
      focusEl.setAttribute("aria-owns", this._itemContainerEl.id);
    }
    this._navigationEmitter = NavigationEmitter.createLinear(el, itemSelector, {
      autoInit: this._options.autoInit,
      autoReset: this._options.autoReset,
      axis: this._options.axis,
      ignoreByDelegateSelector: this._options.ignoreByDelegateSelector,
      wrap: this._options.wrap
    });

    // ensure each item has an id
    this.items.forEach(function (itemEl) {
      (0, _makeupNextId.default)(itemEl);
    });
  }
  get index() {
    return this._navigationEmitter.model.index;
  }
  set index(newIndex) {
    this._navigationEmitter.model.index = newIndex;
  }
  reset() {
    this._navigationEmitter.model.reset();
  }
  get currentItem() {
    return this._navigationEmitter.model.currentItem;
  }
  get items() {
    return this._navigationEmitter.model.items;
  }
  set wrap(newWrap) {
    this._navigationEmitter.model.options.wrap = newWrap;
  }
  destroy() {
    super.destroy();
    this._navigationEmitter.destroy();
  }
}

/*
class GridActiveDescendant extends ActiveDescendant {
    constructor(el, focusEl, containerEl, rowSelector, cellSelector) {
        super(el);
    }
}
*/

function createLinear(el, focusEl, itemContainerEl, itemSelector, selectedOptions) {
  return new LinearActiveDescendant(el, focusEl, itemContainerEl, itemSelector, selectedOptions);
}


/***/ }),

/***/ 923:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.addFocusExit = addFocusExit;
exports.removeFocusExit = removeFocusExit;
var _makeupNextId = _interopRequireDefault(__webpack_require__(3937));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const focusExitEmitters = {};
function doFocusExit(el, fromElement, toElement) {
  el.dispatchEvent(new CustomEvent("focusExit", {
    detail: {
      fromElement,
      toElement
    },
    bubbles: false // mirror the native mouseleave event
  }));
}
function onDocumentFocusIn(e) {
  const newFocusElement = e.target;
  const targetIsDescendant = this.el.contains(newFocusElement);

  // if focus has moved to a focusable descendant
  if (targetIsDescendant === true) {
    // set the target as the currently focussed element
    this.currentFocusElement = newFocusElement;
  } else {
    // else focus has not gone to a focusable descendant
    window.removeEventListener("blur", this.onWindowBlurListener);
    document.removeEventListener("focusin", this.onDocumentFocusInListener);
    doFocusExit(this.el, this.currentFocusElement, newFocusElement);
    this.currentFocusElement = null;
  }
}
function onWindowBlur() {
  doFocusExit(this.el, this.currentFocusElement, undefined);
}
function onWidgetFocusIn() {
  // listen for focus moving to anywhere in document
  // note that mouse click on buttons, checkboxes and radios does not trigger focus events in all browsers!
  document.addEventListener("focusin", this.onDocumentFocusInListener);
  // listen for focus leaving the window
  window.addEventListener("blur", this.onWindowBlurListener);
}
class FocusExitEmitter {
  constructor(el) {
    this.el = el;
    this.currentFocusElement = null;
    this.onWidgetFocusInListener = onWidgetFocusIn.bind(this);
    this.onDocumentFocusInListener = onDocumentFocusIn.bind(this);
    this.onWindowBlurListener = onWindowBlur.bind(this);
    this.el.addEventListener("focusin", this.onWidgetFocusInListener);
  }
  removeEventListeners() {
    window.removeEventListener("blur", this.onWindowBlurListener);
    document.removeEventListener("focusin", this.onDocumentFocusInListener);
    this.el.removeEventListener("focusin", this.onWidgetFocusInListener);
  }
}
function addFocusExit(el) {
  let exitEmitter = null;
  (0, _makeupNextId.default)(el);
  if (!focusExitEmitters[el.id]) {
    exitEmitter = new FocusExitEmitter(el);
    focusExitEmitters[el.id] = exitEmitter;
  }
  return exitEmitter;
}
function removeFocusExit(el) {
  const exitEmitter = focusExitEmitters[el.id];
  if (exitEmitter) {
    exitEmitter.removeEventListeners();
    delete focusExitEmitters[el.id];
  }
}


/***/ }),

/***/ 8271:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _makeupNextId = _interopRequireDefault(__webpack_require__(3937));
var ExitEmitter = _interopRequireWildcard(__webpack_require__(923));
var _makeupFocusables = _interopRequireDefault(__webpack_require__(6257));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const defaultOptions = {
  alwaysDoFocusManagement: false,
  ariaControls: true,
  autoCollapse: false,
  collapseOnFocusOut: false,
  collapseOnMouseOut: false,
  collapseOnClickOut: false,
  contentSelector: ".expander__content",
  expandedClass: null,
  expandOnClick: false,
  expandOnFocus: false,
  expandOnHover: false,
  focusManagement: null,
  hostSelector: ".expander__host",
  simulateSpacebarClick: false
};
function onHostKeyDown(e) {
  if (e.keyCode === 13 || e.keyCode === 32) {
    this._keyboardClickFlag = true;
  }
  // if host element does not naturally trigger a click event on spacebar, we can force one to trigger here.
  // careful! if host already triggers click events naturally, we end up with a "double-click".
  if (e.keyCode === 32 && this.options.simulateSpacebarClick === true) {
    this.hostEl.click();
  }
}
function onHostMouseDown() {
  this._mouseClickFlag = true;
}
function onHostClick() {
  this._expandWasKeyboardClickActivated = this._keyboardClickFlag;
  this._expandWasMouseClickActivated = this._mouseClickFlag;
  this.expanded = !this.expanded;
}
function onHostFocus() {
  this._expandWasFocusActivated = true;
  this.expanded = true;
}
function onHostHover() {
  clearTimeout(this._mouseLeft);
  this._expandWasHoverActivated = true;
  this.expanded = true;
}
function onFocusExit() {
  this.expanded = false;
}
function onMouseLeave() {
  clearTimeout(this._mouseLeft);
  this._mouseLeft = setTimeout(() => {
    this.expanded = false;
  }, 300);
}
function _onDocumentClick(e) {
  if (this.el.contains(e.target) === false) {
    this.expanded = false;
  }
}
function _onDocumentTouchStart() {
  this.documentClick = true;
}
function _onDocumentTouchMove() {
  this.documentClick = false;
}
function _onDocumentTouchEnd(e) {
  if (this.documentClick === true) {
    this.documentClick = false;
    if (this.el.contains(e.target) === false) {
      this.expanded = false;
    }
  }
}
function manageFocus(focusManagement, contentEl) {
  if (focusManagement === "content") {
    contentEl.setAttribute("tabindex", "-1");
    contentEl.focus();
  } else if (focusManagement === "focusable") {
    (0, _makeupFocusables.default)(contentEl)[0].focus();
  } else if (focusManagement === "interactive") {
    (0, _makeupFocusables.default)(contentEl, true)[0].focus();
  } else if (focusManagement !== null) {
    const el = contentEl.querySelector("#".concat(focusManagement));
    if (el) {
      el.focus();
    }
  }
}
class _default {
  constructor(el, selectedOptions) {
    this.options = Object.assign({}, defaultOptions, selectedOptions);
    this.el = el;
    this.hostEl = el.querySelector(this.options.hostSelector); // the keyboard focusable host el
    this.contentEl = el.querySelector(this.options.contentSelector);
    ExitEmitter.addFocusExit(this.el);
    this._hostKeyDownListener = onHostKeyDown.bind(this);
    this._hostMouseDownListener = onHostMouseDown.bind(this);
    this._documentClickListener = _onDocumentClick.bind(this);
    this._documentTouchStartListener = _onDocumentTouchStart.bind(this);
    this._documentTouchMoveListener = _onDocumentTouchMove.bind(this);
    this._documentTouchEndListener = _onDocumentTouchEnd.bind(this);
    this._hostClickListener = onHostClick.bind(this);
    this._hostFocusListener = onHostFocus.bind(this);
    this._hostHoverListener = onHostHover.bind(this);
    this._focusExitListener = onFocusExit.bind(this);
    this._mouseLeaveListener = onMouseLeave.bind(this);
    if (this.hostEl.getAttribute("aria-expanded") === null) {
      this.hostEl.setAttribute("aria-expanded", "false");
    }
    if (this.options.ariaControls === true) {
      // ensure the widget has an id
      (0, _makeupNextId.default)(this.el, "expander");
      this.contentEl.id = this.contentEl.id || "".concat(this.el.id, "-content");
      this.hostEl.setAttribute("aria-controls", this.contentEl.id);
    }
    this.expandOnClick = this.options.expandOnClick;
    this.expandOnFocus = this.options.expandOnFocus;
    this.expandOnHover = this.options.expandOnHover;
    if (this.options.autoCollapse === false) {
      this.collapseOnClickOut = this.options.collapseOnClickOut;
      this.collapseOnFocusOut = this.options.collapseOnFocusOut;
      this.collapseOnMouseOut = this.options.collapseOnMouseOut;
    }
  }
  set expandOnClick(bool) {
    if (bool === true) {
      this.hostEl.addEventListener("keydown", this._hostKeyDownListener);
      this.hostEl.addEventListener("mousedown", this._hostMouseDownListener);
      this.hostEl.addEventListener("click", this._hostClickListener);
      if (this.options.autoCollapse === true) {
        this.collapseOnClickOut = true;
        this.collapseOnFocusOut = true;
      }
    } else {
      this.hostEl.removeEventListener("click", this._hostClickListener);
      this.hostEl.removeEventListener("mousedown", this._hostMouseDownListener);
      this.hostEl.removeEventListener("keydown", this._hostKeyDownListener);
    }
  }
  set expandOnFocus(bool) {
    if (bool === true) {
      this.hostEl.addEventListener("focus", this._hostFocusListener);
      if (this.options.autoCollapse === true) {
        this.collapseOnClickOut = true;
        this.collapseOnFocusOut = true;
      }
    } else {
      this.hostEl.removeEventListener("focus", this._hostFocusListener);
    }
  }
  set expandOnHover(bool) {
    if (bool === true) {
      this.hostEl.addEventListener("mouseenter", this._hostHoverListener);
      this.contentEl.addEventListener("mouseenter", this._hostHoverListener);
      if (this.options.autoCollapse === true) {
        this.collapseOnMouseOut = true;
      }
    } else {
      this.hostEl.removeEventListener("mouseenter", this._hostHoverListener);
      this.contentEl.removeEventListener("mouseenter", this._hostHoverListener);
    }
  }
  set collapseOnClickOut(bool) {
    if (bool === true) {
      document.addEventListener("click", this._documentClickListener);
      document.addEventListener("touchstart", this._documentTouchStartListener);
      document.addEventListener("touchmove", this._documentTouchMoveListener);
      document.addEventListener("touchend", this._documentTouchEndListener);
    } else {
      document.removeEventListener("click", this._documentClickListener);
      document.removeEventListener("touchstart", this._documentTouchStartListener);
      document.removeEventListener("touchmove", this._documentTouchMoveListener);
      document.removeEventListener("touchend", this._documentTouchEndListener);
    }
  }
  set collapseOnFocusOut(bool) {
    if (bool === true) {
      this.el.addEventListener("focusExit", this._focusExitListener);
    } else {
      this.el.removeEventListener("focusExit", this._focusExitListener);
    }
  }
  set collapseOnMouseOut(bool) {
    if (bool === true) {
      this.el.addEventListener("mouseleave", this._mouseLeaveListener);
      this.contentEl.addEventListener("mouseleave", this._mouseLeaveListener);
    } else {
      this.el.removeEventListener("mouseleave", this._mouseLeaveListener);
      this.contentEl.removeEventListener("mouseleave", this._mouseLeaveListener);
    }
  }
  get expanded() {
    return this.hostEl.getAttribute("aria-expanded") === "true";
  }
  set expanded(bool) {
    if (bool === true && this.expanded === false) {
      this.hostEl.setAttribute("aria-expanded", "true");
      if (this.options.expandedClass) {
        this.el.classList.add(this.options.expandedClass);
      }
      if (this._expandWasKeyboardClickActivated || this._expandWasMouseClickActivated && this.options.alwaysDoFocusManagement) {
        manageFocus(this.options.focusManagement, this.contentEl);
      }
      this.el.dispatchEvent(new CustomEvent("expander-expand", {
        bubbles: true,
        detail: this.contentEl
      }));
    }
    if (bool === false && this.expanded === true) {
      this.hostEl.setAttribute("aria-expanded", "false");
      if (this.options.expandedClass) {
        this.el.classList.remove(this.options.expandedClass);
      }
      this.el.dispatchEvent(new CustomEvent("expander-collapse", {
        bubbles: true,
        detail: this.contentEl
      }));
    }
    this._expandWasKeyboardClickActivated = false;
    this._expandWasMouseClickActivated = false;
    this._expandWasFocusActivated = false;
    this._expandWasHoverActivated = false;
    this._keyboardClickFlag = false;
    this._mouseClickFlag = false;
  }
  sleep() {
    if (this._destroyed !== true) {
      this.expandOnClick = false;
      this.expandOnFocus = false;
      this.expandOnHover = false;
      this.collapseOnClickOut = false;
      this.collapseOnFocusOut = false;
      this.collapseOnMouseOut = false;
    }
  }
  destroy() {
    this.sleep();
    this._destroyed = true;
    this._hostKeyDownListener = null;
    this._hostMouseDownListener = null;
    this._documentClickListener = null;
    this._documentTouchStartListener = null;
    this._documentTouchMoveListener = null;
    this._documentTouchEndListener = null;
    this._hostClickListener = null;
    this._hostFocusListener = null;
    this._hostHoverListener = null;
    this._focusExitListener = null;
    this._mouseLeaveListener = null;
  }
}
exports["default"] = _default;


/***/ }),

/***/ 6257:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
const focusableElList = ["a[href]", "area[href]", "button:not([disabled])", "embed", "iframe", "input:not([disabled])", "object", "select:not([disabled])", "textarea:not([disabled])", "*[tabindex]", "*[contenteditable]"];
const focusableElSelector = focusableElList.join();
function _default(el) {
  let keyboardOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  let callback = arguments.length > 2 ? arguments[2] : undefined;
  if (callback) {
    const request = requestAnimationFrame(() => {
      callback(getFocusables(el, keyboardOnly));
    });
    return () => {
      cancelAnimationFrame(request);
    };
  }
  return getFocusables(el, keyboardOnly);
}
function getFocusables(el) {
  let keyboardOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  let focusableEls = Array.prototype.slice.call(el.querySelectorAll(focusableElSelector));

  // filter out elements with display: none
  focusableEls = focusableEls.filter(function (focusableEl) {
    return window.getComputedStyle(focusableEl).display !== "none";
  });
  if (keyboardOnly === true) {
    focusableEls = focusableEls.filter(function (focusableEl) {
      return focusableEl.getAttribute("tabindex") !== "-1";
    });
  }
  return focusableEls;
}


/***/ }),

/***/ 6550:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.add = add;
exports.addKeyDown = addKeyDown;
exports.addKeyUp = addKeyUp;
exports.remove = remove;
exports.removeKeyDown = removeKeyDown;
exports.removeKeyUp = removeKeyUp;
function uncapitalizeFirstLetter(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}
function onKeyDownOrUp(evt, el, keyEventType) {
  if (!evt.shiftKey) {
    const key = evt.key;
    switch (key) {
      case "Enter":
      case "Escape":
      case "PageUp":
      case "PageDown":
      case "End":
      case "Home":
      case "ArrowLeft":
      case "ArrowUp":
      case "ArrowRight":
      case "ArrowDown":
        el.dispatchEvent(new CustomEvent(uncapitalizeFirstLetter("".concat(key, "Key").concat(keyEventType)), {
          detail: evt,
          bubbles: true
        }));
        break;
      case " ":
        el.dispatchEvent(new CustomEvent("spacebarKey".concat(keyEventType), {
          detail: evt,
          bubbles: true
        }));
        break;
      default:
        return;
    }
  }
}
function onKeyDown(e) {
  onKeyDownOrUp(e, this, "Down");
}
function onKeyUp(e) {
  onKeyDownOrUp(e, this, "Up");
}
function addKeyDown(el) {
  el.addEventListener("keydown", onKeyDown);
}
function addKeyUp(el) {
  el.addEventListener("keyup", onKeyUp);
}
function removeKeyDown(el) {
  el.removeEventListener("keydown", onKeyDown);
}
function removeKeyUp(el) {
  el.removeEventListener("keyup", onKeyUp);
}
function add(el) {
  addKeyDown(el);
  addKeyUp(el);
}
function remove(el) {
  removeKeyDown(el);
  removeKeyUp(el);
}


/***/ }),

/***/ 8405:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createLinear = createLinear;
var KeyEmitter = _interopRequireWildcard(__webpack_require__(6550));
var ExitEmitter = _interopRequireWildcard(__webpack_require__(923));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const defaultOptions = {
  axis: "both",
  autoInit: "interactive",
  autoReset: "current",
  ignoreByDelegateSelector: null,
  wrap: false
};
function isItemNavigable(el) {
  return !el.hidden && el.getAttribute("aria-disabled") !== "true";
}
function isIndexNavigable(items, index) {
  return index >= 0 && index < items.length ? isItemNavigable(items[index]) : false;
}
function findNavigableItems(items) {
  return items.filter(isItemNavigable);
}
function findFirstNavigableIndex(items) {
  return items.findIndex(item => isItemNavigable(item));
}
function findLastNavigableIndex(items) {
  // todo: at(-1) is more performant than reverse(), but Babel is not transpiling it
  return items.indexOf(findNavigableItems(items).reverse()[0]);
}
function findIndexByAttribute(items, attribute, value) {
  return items.findIndex(item => isItemNavigable(item) && item.getAttribute(attribute) === value);
}
function findFirstNavigableAriaCheckedIndex(items) {
  return findIndexByAttribute(items, "aria-checked", "true");
}
function findFirstNavigableAriaSelectedIndex(items) {
  return findIndexByAttribute(items, "aria-selected", "true");
}
function findIgnoredByDelegateItems(el, options) {
  return options.ignoreByDelegateSelector !== null ? [...el.querySelectorAll(options.ignoreByDelegateSelector)] : [];
}
function findPreviousNavigableIndex(items, index, wrap) {
  let previousNavigableIndex = -1;
  if (index === null || atStart(items, index)) {
    if (wrap === true) {
      previousNavigableIndex = findLastNavigableIndex(items);
    }
  } else {
    let i = index;
    while (--i >= 0) {
      if (isItemNavigable(items[i])) {
        previousNavigableIndex = i;
        break;
      }
    }
  }
  return previousNavigableIndex;
}
function findNextNavigableIndex(items, index, wrap) {
  let nextNavigableIndex = -1;
  if (index === null) {
    nextNavigableIndex = findFirstNavigableIndex(items);
  } else if (atEnd(items, index)) {
    if (wrap === true) {
      nextNavigableIndex = findFirstNavigableIndex(items);
    }
  } else {
    let i = index;
    while (++i < items.length) {
      if (isItemNavigable(items[i])) {
        nextNavigableIndex = i;
        break;
      }
    }
  }
  return nextNavigableIndex;
}

// returning -1 means not found
function findIndexPositionByType(typeOrNum, items, currentIndex) {
  let index = -1;
  switch (typeOrNum) {
    case "none":
      index = null;
      break;
    case "current":
      index = currentIndex;
      break;
    case "interactive":
      index = findFirstNavigableIndex(items);
      break;
    case "ariaChecked":
      index = findFirstNavigableAriaCheckedIndex(items);
      break;
    case "ariaSelected":
      index = findFirstNavigableAriaSelectedIndex(items);
      break;
    case "ariaSelectedOrInteractive":
      index = findFirstNavigableAriaSelectedIndex(items);
      index = index === -1 ? findFirstNavigableIndex(items) : index;
      break;
    default:
      index = typeof typeOrNum === "number" || typeOrNum === null ? typeOrNum : -1;
  }
  return index;
}
function atStart(items, index) {
  return index === findFirstNavigableIndex(items);
}
function atEnd(items, index) {
  return index === findLastNavigableIndex(items);
}
function onKeyPrev(e) {
  const ignoredByDelegateItems = findIgnoredByDelegateItems(this._el, this.options);

  // todo: update KeyEmitter to deal with ignored items?
  if (ignoredByDelegateItems.length === 0 || !ignoredByDelegateItems.includes(e.detail.target)) {
    this.index = findPreviousNavigableIndex(this.items, this.index, this.options.wrap);
  }
}
function onKeyNext(e) {
  const ignoredByDelegateItems = findIgnoredByDelegateItems(this._el, this.options);

  // todo: update KeyEmitter to deal with ignored items?
  if (ignoredByDelegateItems.length === 0 || !ignoredByDelegateItems.includes(e.detail.target)) {
    this.index = findNextNavigableIndex(this.items, this.index, this.options.wrap);
  }
}
function onClick(e) {
  const itemIndex = this.indexOf(e.target.closest(this._itemSelector));
  if (isIndexNavigable(this.items, itemIndex)) {
    this.index = itemIndex;
  }
}
function onKeyHome(e) {
  const ignoredByDelegateItems = findIgnoredByDelegateItems(this._el, this.options);

  // todo: update KeyEmitter to deal with ignored items?
  if (ignoredByDelegateItems.length === 0 || !ignoredByDelegateItems.includes(e.detail.target)) {
    this.index = findFirstNavigableIndex(this.items);
  }
}
function onKeyEnd(e) {
  const ignoredByDelegateItems = findIgnoredByDelegateItems(this._el, this.options);

  // todo: update KeyEmitter to deal with ignored items?
  if (ignoredByDelegateItems.length === 0 || !ignoredByDelegateItems.includes(e.detail.target)) {
    this.index = findLastNavigableIndex(this.items);
  }
}
function onFocusExit() {
  if (this.options.autoReset !== null) {
    this.reset();
  }
}
function onMutation(e) {
  const fromIndex = this.index;
  let toIndex = this.index;
  // https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord
  const {
    addedNodes,
    attributeName,
    removedNodes,
    target,
    type
  } = e[0];
  if (type === "attributes") {
    if (target === this.currentItem) {
      if (attributeName === "aria-disabled") {
        // current item was disabled - keep it as current index (until a keyboard navigation happens)
        toIndex = this.index;
      } else if (attributeName === "hidden") {
        // current item was hidden and focus is lost - reset index to first interactive element
        toIndex = findFirstNavigableIndex(this.items);
      }
    } else {
      toIndex = this.index;
    }
  } else if (type === "childList") {
    if (removedNodes.length > 0 && [...removedNodes].includes(this._cachedElement)) {
      // current item was removed and focus is lost - reset index to first interactive element
      toIndex = findFirstNavigableIndex(this.items);
    } else if (removedNodes.length > 0 || addedNodes.length > 0) {
      // nodes were added and/or removed - keep current item and resync its index
      toIndex = this.indexOf(this._cachedElement);
    }
  }
  this._index = toIndex;
  this._el.dispatchEvent(new CustomEvent("navigationModelMutation", {
    bubbles: false,
    detail: {
      fromIndex,
      toIndex
    }
  }));
}
class NavigationModel {
  /**
   * @param {HTMLElement} el
   * @param {string} itemSelector
   * @param {typeof defaultOptions} selectedOptions
   */
  constructor(el, itemSelector, selectedOptions) {
    /** @member {typeof defaultOptions} */
    this.options = Object.assign({}, defaultOptions, selectedOptions);

    /** @member {HTMLElement} */
    this._el = el;

    /** @member {string} */
    this._itemSelector = itemSelector;
  }
}
class LinearNavigationModel extends NavigationModel {
  /**
   * @param {HTMLElement} el
   * @param {string} itemSelector
   * @param {typeof defaultOptions} selectedOptions
   */
  constructor(el, itemSelector, selectedOptions) {
    super(el, itemSelector, selectedOptions);
    const fromIndex = this._index;
    const toIndex = findIndexPositionByType(this.options.autoInit, this.items, this.index);

    // do not use setter as it will trigger a change event
    this._index = toIndex;

    // always keep an element reference to the last item (for use in mutation observer)
    // todo: convert index to Tuple to store last/current values instead?
    this._cachedElement = this.items[toIndex];
    this._el.dispatchEvent(new CustomEvent("navigationModelInit", {
      bubbles: false,
      detail: {
        firstInteractiveIndex: this.firstNavigableIndex,
        fromIndex,
        items: this.items,
        toIndex
      }
    }));
  }
  get currentItem() {
    return this.items[this.index];
  }

  // todo: code smell as getter abstracts that the query selector re-runs every time getter is accessed
  get items() {
    return [...this._el.querySelectorAll("".concat(this._itemSelector))];
  }
  get index() {
    return this._index;
  }

  /**
   * @param {number} toIndex - update index position in this.items (non-interactive indexes fail silently)
   */
  set index(toIndex) {
    if (toIndex === this.index) {
      return;
    } else if (!isIndexNavigable(this.items, toIndex)) {
      // no-op. throw exception?
    } else {
      const fromIndex = this.index;
      // update cached element reference (for use in mutation observer if DOM node gets removed)
      this._cachedElement = this.items[toIndex];
      this._index = toIndex;
      this._el.dispatchEvent(new CustomEvent("navigationModelChange", {
        bubbles: false,
        detail: {
          fromIndex,
          toIndex
        }
      }));
    }
  }
  indexOf(element) {
    return this.items.indexOf(element);
  }
  reset() {
    const fromIndex = this.index;
    const toIndex = findIndexPositionByType(this.options.autoReset, this.items, this.index);
    if (toIndex !== fromIndex) {
      // do not use setter as it will trigger a navigationModelChange event
      this._index = toIndex;
      this._el.dispatchEvent(new CustomEvent("navigationModelReset", {
        bubbles: false,
        detail: {
          fromIndex,
          toIndex
        }
      }));
    }
  }
}

// 2D Grid Model will go here

/*
class GridModel extends NavigationModel {
    constructor(el, rowSelector, colSelector) {
        super();
        this._coords = null;
    }
}
*/

class NavigationEmitter {
  /**
   * @param {HTMLElement} el
   * @param {LinearNavigationModel} model
   */
  constructor(el, model) {
    this.model = model;
    this.el = el;
    this._keyPrevListener = onKeyPrev.bind(model);
    this._keyNextListener = onKeyNext.bind(model);
    this._keyHomeListener = onKeyHome.bind(model);
    this._keyEndListener = onKeyEnd.bind(model);
    this._clickListener = onClick.bind(model);
    this._focusExitListener = onFocusExit.bind(model);
    this._observer = new MutationObserver(onMutation.bind(model));
    KeyEmitter.addKeyDown(this.el);
    ExitEmitter.addFocusExit(this.el);
    const axis = model.options.axis;
    if (axis === "both" || axis === "x") {
      this.el.addEventListener("arrowLeftKeyDown", this._keyPrevListener);
      this.el.addEventListener("arrowRightKeyDown", this._keyNextListener);
    }
    if (axis === "both" || axis === "y") {
      this.el.addEventListener("arrowUpKeyDown", this._keyPrevListener);
      this.el.addEventListener("arrowDownKeyDown", this._keyNextListener);
    }
    this.el.addEventListener("homeKeyDown", this._keyHomeListener);
    this.el.addEventListener("endKeyDown", this._keyEndListener);
    this.el.addEventListener("click", this._clickListener);
    this.el.addEventListener("focusExit", this._focusExitListener);
    this._observer.observe(this.el, {
      childList: true,
      subtree: true,
      attributeFilter: ["aria-disabled", "hidden"],
      attributes: true,
      attributeOldValue: true
    });
  }
  destroy() {
    KeyEmitter.removeKeyDown(this.el);
    ExitEmitter.removeFocusExit(this.el);
    this.el.removeEventListener("arrowLeftKeyDown", this._keyPrevListener);
    this.el.removeEventListener("arrowRightKeyDown", this._keyNextListener);
    this.el.removeEventListener("arrowUpKeyDown", this._keyPrevListener);
    this.el.removeEventListener("arrowDownKeyDown", this._keyNextListener);
    this.el.removeEventListener("homeKeyDown", this._keyHomeListener);
    this.el.removeEventListener("endKeyDown", this._keyEndListener);
    this.el.removeEventListener("click", this._clickListener);
    this.el.removeEventListener("focusExit", this._focusExitListener);
    this._observer.disconnect();
  }
}
function createLinear(el, itemSelector, selectedOptions) {
  const model = new LinearNavigationModel(el, itemSelector, selectedOptions);
  return new NavigationEmitter(el, model);
}

/*
static createGrid(el, rowSelector, colSelector, selectedOptions) {
    return null;
}
*/


/***/ }),

/***/ 3937:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
const sequenceMap = {};
const defaultPrefix = "nid";
const randomPortion = createRandomPortion(3);
function randomNumber(max) {
  return Math.floor(Math.random() * max);
}
function createRandomPortion(size) {
  const letters = "abcdefghijklmnopqrstuvwxyz";
  const digits = "0123456789";
  const allChars = letters + digits;

  // to ensure a valid HTML ID (when prefix is empty), first character must be a letter
  let portion = letters[randomNumber(25)];

  // start iterating from 1, as we already have our first char
  for (let i = 1; i < size; i++) {
    portion += allChars[randomNumber(35)];
  }
  return portion;
}
function _default(el) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultPrefix;
  const separator = prefix === "" ? "" : "-";

  // join first prefix with random portion to create key
  const key = "".concat(prefix).concat(separator).concat(randomPortion);

  // initialise key in sequence map if necessary
  sequenceMap[key] = sequenceMap[key] || 0;
  if (!el.id) {
    el.setAttribute("id", "".concat(key, "-").concat(sequenceMap[key]++));
  }
  return el.id;
}


/***/ }),

/***/ 9795:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.add = add;
exports.remove = remove;
function onKeyDown(e) {
  if (e.keyCode >= 32 && e.keyCode <= 40) {
    e.preventDefault();
  }
}
function add(el) {
  el.addEventListener("keydown", onKeyDown);
}
function remove(el) {
  el.removeEventListener("keydown", onKeyDown);
}


/***/ }),

/***/ 792:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _makeupExpander = _interopRequireDefault(__webpack_require__(8271));
var _makeupListbox = _interopRequireDefault(__webpack_require__(2760));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const defaultOptions = {
  autoSelect: true,
  collapseTimeout: 150,
  customElementMode: false,
  autoScroll: true
};
class _default {
  constructor(widgetEl, selectedOptions) {
    this._options = Object.assign({}, defaultOptions, selectedOptions);
    this._el = widgetEl;
    this._inputEl = this._el.querySelector("input");
    this._listboxEl = this._el.querySelector(".combobox__listbox");
    this._autocompleteType = this._inputEl.getAttribute("aria-autocomplete");
    this._inputEl.setAttribute("autocomplete", "off");
    this._inputEl.setAttribute("role", "combobox");
    this._listboxEl.hidden = false;
    this._listboxWidget = new _makeupListbox.default(this._listboxEl, {
      activeDescendantClassName: "combobox__option--active",
      autoReset: -1,
      autoSelect: this._options.autoSelect,
      focusableElement: this._inputEl,
      listboxOwnerElement: this._el,
      autoScroll: this._options.autoScroll
    });
    this._expander = new _makeupExpander.default(this._el, {
      collapseOnClickOut: true,
      collapseOnFocusOut: true,
      contentSelector: ".combobox__listbox",
      expandedClass: "combobox--expanded",
      expandOnFocus: true,
      hostSelector: "input"
    });
    this._destroyed = false;
    this._onInputFocusListener = _onInputFocus.bind(this);
    this._onListboxClickListener = _onListboxClick.bind(this);
    this._onListboxActiveDescendantChangeListener = _onListboxActiveDescendantChange.bind(this);
    this._onTextboxKeyDownListener = _onTextboxKeyDown.bind(this);
    this._onTextboxInputListener = _onTextboxInput.bind(this);
    this._onTextboxClickListener = _onTextboxClick.bind(this);
    this._onMutationListener = _onMutation.bind(this);
    this._el.classList.add("combobox--js");
    if (!this._options.customElementMode) {
      this._mutationObserver = new MutationObserver(this._onMutationListener);
      this._observeMutations();
      this._observeEvents();
    }
  }
  resetFilter() {
    this._listboxWidget._activeDescendant.reset();
    this._listboxWidget.items.forEach(el => el.hidden = false);
  }
  _observeMutations() {
    if (!this._options.customElementMode) {
      this._mutationObserver.observe(this._inputEl, {
        attributes: true,
        childList: true,
        subtree: true
      });
    }
  }
  _unobserveMutations() {
    if (!this._options.customElementMode) {
      this._mutationObserver.disconnect();
    }
  }
  _observeEvents() {
    if (this._destroyed !== true) {
      this._listboxEl.addEventListener("click", this._onListboxClickListener);
      this._listboxWidget._activeDescendantRootEl.addEventListener("activeDescendantChange", this._onListboxActiveDescendantChangeListener);
      this._inputEl.addEventListener("focus", this._onInputFocusListener);
      this._inputEl.addEventListener("keydown", this._onTextboxKeyDownListener);
      this._inputEl.addEventListener("input", this._onTextboxInputListener);
      this._inputEl.addEventListener("click", this._onTextboxClickListener);
    }
  }
  _unobserveEvents() {
    this._listboxEl.removeEventListener("click", this._onListboxClickListener);
    this._listboxWidget._activeDescendantRootEl.removeEventListener("activeDescendantChange", this._onListboxActiveDescendantChangeListener);
    this._inputEl.removeEventListener("focus", this._onInputFocusListener);
    this._inputEl.removeEventListener("keydown", this._onTextboxKeyDownListener);
    this._inputEl.removeEventListener("input", this._onTextboxInputListener);
    this._inputEl.removeEventListener("click", this._onTextboxClickListener);
  }
  destroy() {
    this._destroyed = true;
    this._unobserveMutations();
    this._unobserveEvents();
    this._onInputFocusListener = null;
    this._onListboxClickListener = null;
    this._onListboxActiveDesendanctChangeListener = null;
    this._onTextboxKeyDownListener = null;
    this._onTextboxInputListener = null;
    this._onTextboxClickListener = null;
    this._onMutationListener = null;
  }
}
exports["default"] = _default;
function _onInputFocus() {
  this.resetFilter();
}
function _onTextboxKeyDown(e) {
  // up and down keys should not move caret
  if (e.keyCode === 38 || e.keyCode === 40) {
    e.preventDefault();
  }

  // down arrow key should always expand listbox
  if (e.keyCode === 40) {
    if (this._expander.expanded === false) {
      this._expander.expanded = true;
    }
  }

  // escape key should always collapse listbox
  if (e.keyCode === 27) {
    if (this._expander.expanded === true) {
      this._expander.expanded = false;
      this._listboxWidget._activeDescendant.reset();
    }
  }

  // for manual selection, ENTER should not submit form when there is an active descendant
  if (this._options.autoSelect === false && e.keyCode === 13 && this._inputEl.getAttribute("aria-activedescendant")) {
    e.preventDefault();
    const widget = this;
    this._inputEl.value = this._listboxWidget.items[this._listboxWidget._activeDescendant.index].innerText;
    _dispatchChangeEvent(this._el, this._inputEl.value);
    this._listboxWidget._activeDescendant.reset();
    setTimeout(function () {
      widget._expander.expanded = false;
      if (widget._autocompleteType === "list") {
        if (widget._inputEl.value.length === 0) {
          widget.resetFilter();
        } else {
          _filterSuggestions(widget._inputEl.value, widget._listboxWidget.items);
        }
      }
    }, this._options.collapseTimeout);
  }
}
function _onTextboxClick() {
  if (this._expander.expanded === false) {
    this._expander.expanded = true;
  }
}
function _onTextboxInput() {
  if (this._expander.expanded === false) {
    this._expander.expanded = true;
  }
  if (this._autocompleteType === "list") {
    this._listboxWidget._activeDescendant.reset();
    if (this._inputEl.value.length === 0) {
      this.resetFilter();
    } else {
      _filterSuggestions(this._inputEl.value, this._listboxWidget.items);
    }
  }
}
function _onListboxClick(e) {
  const widget = this;
  const element = e.target.closest("[role=option]");
  const indexData = this._listboxWidget.items.indexOf(element);
  console.log(indexData);
  if (indexData !== undefined) {
    this._inputEl.value = this._listboxWidget.items[indexData].innerText;
    if (this._options.autoSelect === false) {
      _dispatchChangeEvent(this._el, this._inputEl.value);
    }
    setTimeout(function () {
      widget._expander.expanded = false;
    }, this._options.collapseTimeout);
  }
}
function _onListboxActiveDescendantChange(e) {
  if (this._options.autoSelect === true) {
    this._inputEl.value = this._listboxWidget.items[e.detail.toIndex].innerText;
    _dispatchChangeEvent(this._el, this._inputEl.value);
  }
}
function _onMutation(mutationsList) {
  for (const mutation of mutationsList) {
    if (mutation.type === "attributes") {
      this._el.dispatchEvent(new CustomEvent("makeup-combobox-mutation", {
        detail: {
          attributeName: mutation.attributeName
        }
      }));
    }
  }
}
function _filterSuggestions(value, items) {
  const numChars = value.length;
  const currentValue = value.toLowerCase();
  const matchedItems = items.filter(el => {
    return el.innerText.trim().substring(0, numChars).toLowerCase() === currentValue;
  });
  const unmatchedItems = items.filter(el => {
    return el.innerText.trim().substring(0, numChars).toLowerCase() !== currentValue;
  });
  matchedItems.forEach(el => el.hidden = false);
  unmatchedItems.forEach(el => el.hidden = true);
}
function _dispatchChangeEvent(el, value) {
  el.dispatchEvent(new CustomEvent("makeup-combobox-change", {
    detail: {
      value
    }
  }));
}


/***/ }),

/***/ 2760:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var ActiveDescendant = _interopRequireWildcard(__webpack_require__(2960));
var PreventScrollKeys = _interopRequireWildcard(__webpack_require__(9795));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * A listbox can be a standalone focusable widget, or controlled by a separate, focusable widget
 * (a textbox for example, in the case of a combobox or datepicker)
 *
 * This listbox code currently supports single-selct only!
 * This code has been copied from Skin & MIND Patterns and has not yet been cleaned up.
 */

const defaultOptions = {
  activeDescendantClassName: "listbox__option--active",
  // the classname applied to the current active desdcendant
  autoInit: "ariaSelectedOrInteractive",
  autoReset: "ariaSelectedOrInteractive",
  autoSelect: true,
  // when true, aria-checked state matches active-descendant
  autoScroll: true,
  // when true, the listbox will scroll to keep the activeDescendant in view
  customElementMode: false,
  focusableElement: null,
  // used in a combobox/datepicker scenario
  listboxOwnerElement: null,
  // used in a combobox/datepicker scenario
  multiSelect: false,
  // todo
  useAriaChecked: true,
  // doubles up on support for aria-selected to announce visible selected/checked state
  valueSelector: ".listbox__value" // Selector to get value from
};
function isSpacebarOrEnter(keyCode) {
  return keyCode === 13 || keyCode === 32;
}
class _default {
  constructor(widgetEl, selectedOptions) {
    this._options = Object.assign({}, defaultOptions, selectedOptions);
    this.el = widgetEl;

    // in cases such as combobox, the active-descendant logic is controlled by a parent widget
    this._activeDescendantRootEl = this._options.listboxOwnerElement || this.el;

    // todo: not sure this check is needed any more
    if (widgetEl.getAttribute("role") === "listbox") {
      this._listboxEl = widgetEl;
    } else {
      this._listboxEl = this.el.querySelector("[role=listbox]");
    }
    if (!this._options.focusableElement && this._listboxEl.getAttribute("tabindex") === null) {
      this._listboxEl.setAttribute("tabindex", "0");
    }
    PreventScrollKeys.add(this.el);
    this._onKeyDownListener = _onKeyDown.bind(this);
    this._onClickListener = _onClick.bind(this);
    this._onActiveDescendantChangeListener = _onActiveDescendantChange.bind(this);
    this._onMutationListener = _onMutation.bind(this);
    this.el.classList.add("listbox--js");
    if (!this._options.customElementMode) {
      this._mutationObserver = new MutationObserver(this._onMutationListener);
      this._observeMutations();
      this._observeEvents();
    }
    this._activeDescendant = ActiveDescendant.createLinear(this._activeDescendantRootEl, this._options.focusableElement || this._listboxEl, this._listboxEl, "[role=option]", {
      activeDescendantClassName: this._options.activeDescendantClassName,
      autoInit: this._options.autoInit,
      autoReset: this._options.autoReset,
      autoScroll: this._options.autoScroll,
      axis: "y"
    });
  }
  _observeMutations() {
    if (!this._options.customElementMode) {
      this._mutationObserver.observe(this._listboxEl, {
        attributeFilter: ["aria-selected"],
        attributes: true,
        childList: true,
        subtree: true
      });
    }
  }
  _unobserveMutations() {
    if (!this._options.customElementMode) {
      this._mutationObserver.disconnect();
    }
  }
  _observeEvents() {
    if (this._destroyed !== true) {
      this._activeDescendantRootEl.addEventListener("activeDescendantChange", this._onActiveDescendantChangeListener);
      this._listboxEl.addEventListener("keydown", this._onKeyDownListener);
      this._listboxEl.addEventListener("click", this._onClickListener);
    }
  }
  _unobserveEvents() {
    this._listboxEl.removeEventListener("keydown", this._onKeyDownListener);
    this._listboxEl.removeEventListener("click", this._onClickListener);
    this._activeDescendantRootEl.removeEventListener("activeDescendantChange", this._onActiveDescendantChangeListener);
  }
  get index() {
    return this.items.findIndex(el => el.getAttribute("aria-selected") === "true");
  }
  get items() {
    return this._activeDescendant.items;
  }
  select(index) {
    this._unobserveMutations();
    const itemEl = this.items[index];
    if (itemEl && itemEl.getAttribute("aria-disabled") !== "true") {
      const matchingItem = this.items[index];
      let optionValue;
      matchingItem.setAttribute("aria-selected", "true");
      if (this._options.useAriaChecked === true) {
        matchingItem.setAttribute("aria-checked", "true");
      }
      optionValue = matchingItem.innerText;

      // Check if value selector is present and use that to get innerText instead
      // If its not present, will default to innerText of the whole item
      if (this._options.valueSelector) {
        const valueSelector = matchingItem.querySelector(this._options.valueSelector);
        if (valueSelector) {
          optionValue = valueSelector.innerText;
        }
      }
      this.el.dispatchEvent(new CustomEvent("makeup-listbox-change", {
        detail: {
          el: matchingItem,
          optionIndex: index,
          optionValue
        }
      }));
    }
    this._observeMutations();
  }
  unselect(index) {
    this._unobserveMutations();
    const itemEl = this.items[index];
    if (itemEl && itemEl.getAttribute("aria-disabled") !== "true") {
      const matchingItem = this.items[index];
      matchingItem.setAttribute("aria-selected", "false");
      if (this._options.useAriaChecked === true) {
        matchingItem.setAttribute("aria-checked", "false");
      }
    }
    this._observeMutations();
  }
  destroy() {
    this._destroyed = true;
    this._unobserveMutations();
    this._unobserveEvents();
    this._onKeyDownListener = null;
    this._onClickListener = null;
    this._onActiveDescendantChangeListener = null;
    this._onMutationListener = null;
  }
}
exports["default"] = _default;
function _onKeyDown(e) {
  const activeDescendantEl = this._activeDescendant.currentItem;
  if (isSpacebarOrEnter(e.keyCode) && (activeDescendantEl === null || activeDescendantEl === void 0 ? void 0 : activeDescendantEl.getAttribute("aria-selected")) !== "true") {
    // todo: this.select() should take care of unselecting any existing selections
    this.unselect(this.index);
    this.select(this._activeDescendant.index);
  }
}
function _onClick(e) {
  // unlike the keyDown event, the click event target can be a child element of the option
  // e.g. <div role="option"><span>Item 1</span></div>
  const toEl = e.target.closest("[role=option]");
  const toElIndex = this.items.indexOf(toEl);
  const isTolElSelected = toEl.getAttribute("aria-selected") === "true";
  const isTolElDisabled = toEl.getAttribute("aria-disabled") === "true";
  if (!isTolElDisabled && this._options.autoSelect === false && isTolElSelected === false) {
    // todo: this.select() should take care of unselecting any existing selections
    this.unselect(this.index);
    this.select(toElIndex);
  }
}
function _onActiveDescendantChange(e) {
  const {
    fromIndex,
    toIndex
  } = e.detail;
  if (this._options.autoSelect === true) {
    const fromEl = this.items[fromIndex];
    const toEl = this.items[toIndex];
    if (fromEl) {
      // todo: this.select() should take care of unselecting any existing selections
      this.unselect(fromIndex);
    }
    if (toEl) {
      this.select(toIndex);
    }
  }
}
function _onMutation(mutationsList) {
  for (const mutation of mutationsList) {
    if (mutation.type === "attributes") {
      this.el.dispatchEvent(new CustomEvent("makeup-listbox-mutation", {
        detail: {
          attributeName: mutation.attributeName
        }
      }));
    }
  }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";


__webpack_require__(5957);
__webpack_require__(4658);
__webpack_require__(5015);
__webpack_require__(2915);
var _makeupCombobox = _interopRequireDefault(__webpack_require__(792));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// REQUIRE
// const Combobox = require('makeup-combobox').default;

// IMPORT

window.onload = function () {
  document.querySelectorAll(".combobox").forEach(function (el, i) {
    const widget = new _makeupCombobox.default(el, {
      autoSelect: el.dataset.makeupAutoSelect === "false" ? false : true
    });
    el.addEventListener("makeup-combobox-change", function (e) {
      console.log(e.type, e.detail);
    });
    el.addEventListener("makeup-combobox-mutation", function (e) {
      console.log(e.type, e.detail);
    });
  });
};
})();

/******/ })()
;
//# sourceMappingURL=index.min.js.map